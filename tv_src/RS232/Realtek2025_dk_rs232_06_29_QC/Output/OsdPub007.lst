C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 1   


C51 COMPILER V8.16, COMPILATION OF MODULE OSDPUB007
OBJECT MODULE PLACED IN .\Output\OsdPub007.obj
COMPILER INVOKED BY: D:\安装文件\keil\C51\BIN\C51.EXE gmiOSD\OSD007\OsdPub007.c OPTIMIZE(9,SIZE) BROWSE DEFINE(CMOS_CHIP
                    -_TYPE=PCB_2025LV13) PRINT(.\Output\OsdPub007.lst) OBJECT(.\Output\OsdPub007.obj)

line level    source

   1          #define __OSD007_LCD_OSD__
   2          
   3          #include "Header\Include.h"
   4          
   5          #if(_OSD_TYPE == _OSD007)
   6          #if(IR_Test_EN== _ON)    
                      extern void Display_IR(); 
              #endif
   9          
  10          //-----------------------------------------------------------
  11          void COsdHandler(void)
  12          {    
  13   1      
  14   1          COsdSystemFlowProc();
  15   1          COsdEventMsgProc();
  16   1      
  17   1      
  18   1          if (_PWOFF_STATE == ucCurrState) 
  19   1              return;
  20   1          
  21   1              
  22   1                  switch(ucKeyMessage)
  23   1                  {
  24   2                      case VK_SOURCE:
  25   2                      case VK_IR_TV:
  26   2                      case VK_IR_AV:
  27   2                        case VK_IR_SV:
  28   2                        case VK_IR_SCART:
  29   2                        case VK_IR_VGA:
  30   2                        case VK_AUTO:
  31   2                           switch(ucCurrState)
  32   2                          {
  33   3                              case _ACTIVE_STATE:
  34   3                              case _NOSUPPORT_STATE:
  35   3                              case _NOSIGNAL_STATE:
  36   3                              case _SLEEP_STATE:
  37   3                              case _SOURCE_CHANGE_STATE:
  38   3                                      CSourceChange();
  39   3                                     return;
  40   3                             default:   break;
  41   3                              }
  42   2                              return; 
  43   2                      default:   break;                                
  44   2                      }                
  45   1      
  46   1      #if(_CHANGE_SOURCE_METHOD == _CHANGE_SOURCE_METHOD_0)
  47   1          if (ucChangeSourceCount)
  48   1              CChangeSourceHandler();
  49   1      #endif   
  50   1      
  51   1      #if(_FACTORY_MENU_EN)
  52   1      #if( _BURNIN_EN)                
  53   1                if(GET_BURNIN_STATE()==BURNIN_ON)
  54   1                      {
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 2   

  55   2                   BurnInRun();
  56   2                      }                       
  57   1      #endif           
  58   1              if(GET_FAC_STATE()==1)
  59   1                          COsdFacHandler();
  60   1      #endif
  61   1      
  62   1      #if(_VIDEO_TV_SUPPORT)
  63   1          if ((_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV || ucCurrState == _ACTIVE_STATE) &&GET_FAC_STATE()==0)
  64   1      #else
                  if ((ucCurrState == _ACTIVE_STATE) &&GET_FAC_STATE()==0)
              #endif
  67   1          {          
  68   2              COsdProc();
  69   2      
  70   2              if (bRCallOSD)
  71   2              {
  72   3                  bRCallOSD = 0;
  73   3                  COsdProc();
  74   3              }
  75   2      
  76   2      #if(_VIDEO_TV_SUPPORT)
  77   2              if (ucKeyMessage != _NONE_KEY_MESSAGE && ucOsdState != MENU_SHOW_MUTE_STATE && !bChangeChannel)
  78   2      #else
                      if (ucKeyMessage != _NONE_KEY_MESSAGE && ucOsdState != MENU_SHOW_MUTE_STATE)
              #endif
  81   2              {
  82   3      #if(_IR_ENABLE)        
  83   3                  switch(ucKeyMessage)
  84   3                  {
  85   4                      case VK_IR_DISPLAY:
  86   4                      case VK_IR_MUTE:
  87   4                      case _IR_IMAGE_KEY_MESSAGE:
  88   4                        case VK_IR_SLEEP:
  89   4                          CTimerReactiveTimerEvent(SEC(5),COsdDispOsdTimerEvent);
  90   4                          return;
  91   4      
  92   4                      default:
  93   4                          if(stOsdUserData.OsdTimeout > 4)
  94   4                          {
  95   5                              CTimerReactiveTimerEvent(SEC(stOsdUserData.OsdTimeout),COsdDispOsdTimerEvent);
  96   5                          }
  97   4                          else
  98   4                          {
  99   5                             CTimerCancelTimerEvent(COsdDispOsdTimerEvent);
 100   5                          }
 101   4                  }
 102   3      #endif
 103   3          }  
 104   2         if(GET_MUTE_STATE() == STATE_MUTEON &&ucOsdState==MENU_SHOW_MUTE_STATE)
 105   2              {
 106   3          COsdFxEnableOsd();
 107   3              }
 108   2          if (ucOsdState == 255)
 109   2             NotUseFunc();
 110   2      }
 111   1      #if(IR_Test_EN== _ON)    
                      Display_IR(); 
              #endif
 114   1      }
 115          //-----------------------------------------------------------
 116          
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 3   

 117          void CSourceChange(void)
 118          {
 119   1      #if(_CHANGE_SOURCE_METHOD == _CHANGE_SOURCE_METHOD_0)
 120   1      
 121   1          
 122   1          ChangeSource();
 123   1      
 124   1          if (!ucChangeSourceCount)
 125   1          {
 126   2              MUTE_ON();
 127   2      
 128   2              if (_SLEEP_STATE == ucCurrState)
 129   2                  CPowerLVDSOn();
 130   2              
 131   2        #if(_VIDEO_TV_SUPPORT)
 132   2              ucVideoNoModeTime = 252;
 133   2        #endif        
 134   2              CModeResetMode();
 135   2          }
 136   1          
 137   1          ucChangeSourceCount = 1;
 138   1          ucOsdEventMsg       = _DO_SHOW_NOTE;
 139   1                 SET_DO_SHOW_NOTE(0);
 140   1          ucCurrState         = _SOURCE_CHANGE_STATE;
 141   1          #if(_IR_ENABLE)
 142   1          ucDetectIR_Cmd = 0;
 143   1          #endif
 144   1      
 145   1      #elif(_CHANGE_SOURCE_METHOD == _CHANGE_SOURCE_METHOD_1)
              
                  if (_SLEEP_STATE == ucCurrState)
                      CPowerLVDSOn();
                      
                  ChangeSource();
              //    COsdDispFirstTimeLoadFont();
              
                #if(_VIDEO_TV_SUPPORT)
                  ucVideoNoModeTime = 252;
                #endif        
                  CModeResetMode();
              
                  //SET_FIRST_SHOW_NOTE();
                  ucOsdEventMsg  = _CHANGE_SOURCE_MSG;
                  ucCurrState    = _SOURCE_CHANGE_STATE;
                  #if(_IR_ENABLE)
                  ucDetectIR_Cmd = 0;
                  #endif
              
              #endif  // #if(_CHANGE_SOURCE_METHOD == _CHANGE_SOURCE_METHOD_0)
 166   1      
 167   1      }
 168          //-----------------------------------------------------------
 169          
 170          #if(_CHANGE_SOURCE_METHOD == _CHANGE_SOURCE_METHOD_0)
 171          
 172          void CChangeSourceHandler(void)
 173          {
 174   1          ucChangeSourceCount++;
 175   1      #if(DVD_EN)
 176   1         if(_GET_INPUT_SOURCE() != _SOURCE_VIDEO_DVD)
 177   1         {
 178   2                      bDVD_PWR_OFF();
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 4   

 179   2                      bDVDON = 1;
 180   2              }
 181   1      #endif
 182   1                                
 183   1          if (_CHANGE_SOURCE_TIME < ucChangeSourceCount)
 184   1          {          
 185   2      #if(_VIDEO_SUPPORT == _ON)
 186   2              if (bVideoON && 
 187   2                  (_GET_INPUT_SOURCE() == _SOURCE_VGA || 
 188   2                  _GET_INPUT_SOURCE() == _SOURCE_DVI  || 
 189   2                  _GET_INPUT_SOURCE() == _SOURCE_HDMI || 
 190   2                  _GET_INPUT_SOURCE() == _SOURCE_YPBPR))  // Prev source is video
 191   2              {
 192   3                  gmi_CVDCOutputDisable();
 193   3                  CPowerDownVDC();
 194   3                  bVideoON = 0;
 195   3              } 
 196   2      #endif   
 197   2       
 198   2              ucOsdEventMsg       = _CHANGE_SOURCE_MSG;
 199   2              ucChangeSourceCount = 0;
 200   2              CInitInputSource();
 201   2           //   COsdDispFirstTimeLoadFont();
 202   2          }
 203   1      }      
 204          #endif
 205          //-----------------------------------------------------------
 206          
 207          void COsdSystemFlowProc(void)
 208          {
 209   1          switch(ucCurrState)
 210   1          {
 211   2          case _PWOFF_STATE:
 212   2              break;
 213   2              
 214   2          case _INITIAL_STATE:
 215   2              break;
 216   2              
 217   2          case _SEARCH_STATE:
 218   2              if(GET_FIRST_LOADFONT() == _TRUE)
 219   2              {
 220   3                  CLR_FIRST_LOADFONT();
 221   3                  COsdDispFirstTimeLoadFont();
 222   3              }
 223   2              break;
 224   2              
 225   2          case _ACTIVE_STATE:
 226   2              if(GET_OSD_READYFORDISPLAY() == _TRUE)
 227   2              {         
 228   3                  CLR_OSD_READYFORDISPLAY();
 229   3      /*
 230   3      #if(_CHANGE_SOURCE_BACKGROUCD_COLOR==_BACK_COLOR)                                               
 231   3                      CAdjustBackgroundColor(0x00, 0x00, 0x00);     
 232   3      #else
 233   3                      CAdjustBackgroundColor(0x00, 0x00, 0xFF);     
 234   3      #endif
 235   3      */
 236   3      
 237   3                   MUTE_OFF();
 238   3      #if(RunLED==RedLED)                     
                              CPowerLedRed(); 
              #elif(RunLED==GreenLED)                 
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 5   

 241   3                      CPowerLedGreen(); 
 242   3      #elif(RunLED==OrangeLED)                        
                              CPowerLedOrange(); 
              #elif(RunLED==BlackLED)                 
                              CPowerLedBlack(); 
              #endif
 247   3                  
 248   3                  if (GET_FIRST_SHOW_NOTE())
 249   3                  {
 250   4                      ucOsdEventMsg = _DO_SHOW_NOTE;
 251   4                      CLR_FIRST_SHOW_NOTE();
 252   4                  }
 253   3      #if(_VIDEO_TV_SUPPORT)
 254   3                  else if (_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV && 0 == bChangeChannel)
 255   3                      CShowTVNumber(stVDCColor.CurrentChannel,_SHOW_CH_TV_NUMBER | _SHOW_CH_TV_TYPE | _SHOW_CH_S
             -OUND_TYPE);
 256   3      #endif
 257   3      
 258   3      #if(_VIDEO_CHIP == _VDC_TB1334)
 259   3                  if (_GET_INPUT_SOURCE() != _SOURCE_VIDEO_TV)
 260   3      #endif
 261   3                  CSetVolume();
 262   3              }
 263   2      
 264   2      #if(_VIDEO_CHIP == _VDC_TB1334)
 265   2              CAudioCtrl(); 
 266   2      #endif
 267   2              break;
 268   2              
 269   2          case _NOSUPPORT_STATE:
 270   2                      if(GET_NOSIGNAL_INFO()==1)
 271   2                      return;
 272   2              if(GET_OSD_READYFORDISPLAY() == _TRUE)
 273   2              {
 274   3      #if(NosignalStateLED==RedLED)                   
 275   3                      CPowerLedRed(); 
 276   3      #elif(NosignalStateLED==GreenLED)                       
                              CPowerLedGreen(); 
              #elif(NosignalStateLED==OrangeLED)                      
                              CPowerLedOrange(); 
              #elif(NosignalStateLED==BlackLED)                       
                              CPowerLedBlack(); 
              #endif
 283   3                  CLR_OSD_READYFORDISPLAY();
 284   3      
 285   3      #if(_CHANGE_SOURCE_BACKGROUCD_COLOR==_BACK_COLOR)                                               
 286   3                      CAdjustBackgroundColor(0x00, 0x00, 0x00);     
 287   3      #else
                              CAdjustBackgroundColor(0x00, 0x00, 0xFF);     
              #endif
 290   3                      ucOsdEventMsg = _DO_SHOW_NOTE; 
 291   3                  
 292   3                  CTimerReactiveTimerEvent(SEC(1), CModeNoSupportEvent);
 293   3                      #if(_AUTO_SLEEP_POWERDOWN == _ON)
                                      CTimerActiveTimerEvent(90000, CModePowerSavingEvent);
                              #else
 296   3                              CTimerActiveTimerEvent(SEC(6), CModePowerSavingEvent);
 297   3                      #endif
 298   3              }
 299   2              
 300   2              break;
 301   2              
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 6   

 302   2          case _NOSIGNAL_STATE:
 303   2                      if(GET_NOSIGNAL_INFO()==1)
 304   2                      return;
 305   2              if(GET_OSD_READYFORDISPLAY() == _TRUE)
 306   2              {
 307   3      #if(NosignalStateLED==RedLED)                   
 308   3                      CPowerLedRed(); 
 309   3      #elif(NosignalStateLED==GreenLED)                       
                              CPowerLedGreen(); 
              #elif(NosignalStateLED==OrangeLED)                      
                              CPowerLedOrange(); 
              #elif(NosignalStateLED==BlackLED)                       
                              CPowerLedBlack(); 
              #endif
 316   3                  CLR_OSD_READYFORDISPLAY();
 317   3                  
 318   3      #if(_AUTO_SCAN_SOURCE) 
                          SET_SOURCE_AUTOCHANGE();
              #endif
 321   3                  
 322   3      #if(_CHANGE_SOURCE_BACKGROUCD_COLOR==_BACK_COLOR)                                               
 323   3                      CAdjustBackgroundColor(0x00, 0x00, 0x00);     
 324   3      #else
                              CAdjustBackgroundColor(0x00, 0x00, 0xFF);     
              #endif
 327   3                      ucOsdEventMsg    = _DO_SHOW_NOTE;
 328   3                  
 329   3      #if(_HDMI_SUPPORT == _ON)
                          if((bVGACONNECT && _SOURCE_VGA ==_GET_INPUT_SOURCE()) || (bHDMICONNECT && _SOURCE_HDMI ==_GET_
             -INPUT_SOURCE()))
              #elif(_TMDS_SUPPORT == _ON)
                          if((bVGACONNECT && _SOURCE_VGA ==_GET_INPUT_SOURCE()) || (bDVICONNECT && _SOURCE_DVI ==_GET_IN
             -PUT_SOURCE()))
              #else
 334   3                  if((bVGACONNECT && _SOURCE_VGA ==_GET_INPUT_SOURCE()))
 335   3      #endif
 336   3                  {
 337   4                      CTimerReactiveTimerEvent(SEC(1), CModeNoCableEvent);
 338   4                  }
 339   3                  else
 340   3                  {
 341   4                      CTimerReactiveTimerEvent(SEC(1), CModeNoSignalEvent);
 342   4                   }    
 343   3      //#if(!_BURNIN_EN)  
 344   3                      CTimerActiveTimerEvent(SEC(6), CModePowerSavingEvent);
 345   3      //#endif
 346   3                 
 347   3                  }
 348   2              
 349   2              break;
 350   2              
 351   2          case _SLEEP_STATE:
 352   2              break;
 353   2              
 354   2          default:
 355   2              break;
 356   2          }
 357   1      }
 358          
 359          //-----------------------------------------------------------
 360          
 361          void COsdProc(void)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 7   

 362          {               
 363   1      #if(_VIDEO_TV_SUPPORT)           
 364   1          if (MENU_SHOW_MESSAGE_SATAE == ucOsdState)
 365   1          {
 366   2              if (_NONE_KEY_MESSAGE != ucKeyMessage)
 367   2                  ucOsdState = _MENU_NONE;
 368   2              else
 369   2                  return;
 370   2          }
 371   1      #endif
 372   1      
 373   1          switch(ucOsdState)
 374   1          {
 375   2              case MENU_SHOW_MUTE_STATE:
 376   2              case MENU_SHOW_MSG_STATE:
 377   2              case _MENU_NONE:                    MPubNoneProc();           break;
 378   2      
 379   2              //==================== Main item ===========================
 380   2              case MENU_MAIN_COLOR:        // Public color item
 381   2      #if(_VGA_SUPPORT || _YPBPR_SUPPORT)                   
 382   2              case MENU_MAIN_PICTURE:      // VGA picture item
 383   2      #endif
 384   2      #if(_VIDEO_TV_SUPPORT)           
 385   2              case MENU_MAIN_TV_FUNC:      // TV function item
 386   2      #endif
 387   2              case MENU_MAIN_OSD_FUNC:     // Public OSD function item
 388   2              case MENU_MAIN_SOUND:        // Public Sound item
 389   2              case MENU_MAIN_OTHER:        // Public other item
 390   2              case MENU_MAIN_EXIT:         // Public exit item
 391   2                  MMainItemProc();       
 392   2                  break;
 393   2          
 394   2      
 395   2      
 396   2              //======================= Sub item =========================
 397   2      
 398   2              //---------------- Public Color Sub item -------------------
 399   2              case MENU_ITEM_BRIGHT:       // Public <Brightness>
 400   2              case MENU_ITEM_CONTRAST:     // Public <Contrast>
 401   2      #if(_TMDS_SUPPORT || _VGA_SUPPORT || _HDMI_SUPPORT)
 402   2              case MENU_ITEM_COLOR_TEMP:   // VGA/DVI/HDMI <Color temp>
 403   2      #endif
 404   2      
 405   2      #if(_VIDEO_SUPPORT)
 406   2              case MENU_AV_SATURATION:     // Video <Saturation>
 407   2              case MENU_AV_HUE:            // Video <Hue>
 408   2      #endif
 409   2              case MENU_SUB_COLOR_CLOSE:   // Public <Close> 
 410   2                  MColorSubItemProc();
 411   2                  break;
 412   2      
 413   2              //------------------ TV function sub item -------------------
 414   2      #if(_VIDEO_TV_SUPPORT)
 415   2              case MENU_AUTO_SEARCH:       // TV <Auto search>
 416   2              case MENU_MANUAL_SEARCH:     // TV <Manual search> 
 417   2              case MENU_TUNING:            // TV <Tunning>
 418   2              case MENU_CHANNEL:           // TV <Channel>
 419   2              case MENU_TV_SYSTEM:         // TV <TV system>
 420   2              case MENU_SWAP:              // TV <Swap>
 421   2              case MENU_SKIP:              // TV <Skip>
 422   2              case MENU_SUB_TV_FUNC_CLOSE: // TV <Close>
 423   2                  MTVFuncSubItemProc();
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 8   

 424   2                  break;
 425   2      #endif
 426   2          
 427   2              //------------- VGA/DVI/HDMI Color sub temp sub item -------------
 428   2      #if(_TMDS_SUPPORT || _VGA_SUPPORT || _HDMI_SUPPORT)           
 429   2      #if(_COLOR_TEMP)
                      case MENU_SUB_CT_9300:       // VGA/DVI/HDMI <9300>
                      case MENU_SUB_CT_6500:       // VGA/DVI/HDMI <6500>
                      case MENU_SUB_CT_5800:       // VGA/DVI/HDMI <5800>
                      case MENU_SUB_CT_SRGB:       // VGA/DVI/HDMI <SRGB>
                      case MENU_SUB_CT_USER:       // VGA/DVI/HDMI <User>
                      case MENU_SUB_CT_CLOSE:      // VGA/DVI/HDMI <close>
                          MColorTempSubItemProc();
                          break;
              
                      case MENU_SUB_CT_R:          // VGA/DVI/HDMI <R>
                      case MENU_SUB_CT_G:          // VGA/DVI/HDMI <G>
                      case MENU_SUB_CT_B:          // VGA/DVI/HDMI <B>
                          MColorTempUserItemProc();
                          break;
              #endif
 445   2      #endif
 446   2          
 447   2             //------------------- VGA pciture sub item -------------------
 448   2      #if(_VGA_SUPPORT  || _YPBPR_SUPPORT)
 449   2              case MENU_ITEM_AUTO:         // VGA <Auto>
 450   2      #if(_VGA_SUPPORT)
 451   2              case MENU_ITEM_AUTO_COLOR:
 452   2              case MENU_ITEM_HPOS:         // VGA <H position>
 453   2              case MENU_ITEM_VPOS:         // VGA <V position>
 454   2              case MENU_ITEM_PHASE:        // VGA <Phase>
 455   2              case MENU_ITEM_CLOCK:        // VGA <Clock>
 456   2      #endif
 457   2              case MENU_SUB_PICTURE_CLOSE: // VGA <Close>
 458   2                  MPictureSubItemProc();
 459   2                  break;
 460   2      #endif
 461   2          
 462   2              //------------- Public OSD function sub item ----------------
 463   2              case MENU_SUB_LANGUAGE:        // Public <Language>
 464   2              case MENU_SUB_H_POSITION:      // Public <OSD H position>
 465   2              case MENU_SUB_V_POSITION:      // Public <OSD V position>
 466   2              case MENU_SUB_OSD_TIMEOUT:     // Public <OSD timeout>
 467   2              case MENU_SUB_OSD_TRANSLUCENT: // Public <OSD Translucent>
 468   2              case MENU_SUB_OSD_SIZE:        // public <OSD Size>
 469   2               case MENU_SUB_DISMODE:                 // 16:9-4:3 display
 470   2              case MENU_SUB_OSD_CLOSE:       // Public <Close>
 471   2                  MOSDSubItemProc();
 472   2                  break;
 473   2      
 474   2              //---------------- Public Sound sub item ---------------------
 475   2              case MENU_SUB_VOLUME:        // Public <Volume>
 476   2              case MENU_SUB_MUTE:          // Public <Mute>
 477   2      #if(_SOUND_PROCESSOR == _ENABLE)
                      case MENU_SUB_BALANCE:       // Public <Balance>
                      case MENU_SUB_BASS:          // Public <Bass>
                      case MENU_SUB_TREBLE:        // Public <Treble>
                      case MENU_SUB_SRS:           // Public <SRS>
                      case MENU_SUB_BBE:           // Public <BBE>
              #endif  
 484   2              case MENU_SUB_SOUND_CLOSE:   // Public <Close>
 485   2                  MSoundSubItemProc();
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 9   

 486   2                  break;
 487   2      
 488   2              //------------------ Public Other sub item --------------------
 489   2              case MENU_SUB_RESET:         // Public <Reset>
 490   2              case MENU_SUB_BLUE:          // Public <Blue>
 491   2      #if(_AUTO_POWER_DOWN)
 492   2              case MENU_SUB_AUTO_POWER:    // Public <Auto power down>
 493   2      #endif
 494   2              case MENU_SUB_COLOR_MODE:    // Public <Color Mode>
 495   2              case MENU_SUB_SHARP:         // Public <Sharp>
 496   2              case MENU_SUB_OTHER_CLOSE:   // Public <Close>
 497   2                  MOtherSubItemProc();
 498   2                  break;
 499   2          
 500   2      
 501   2              //======================= Sub item adjust proc =====================
 502   2      
 503   2              //------------------- Public Color adj proc ----------------------
 504   2              case MENU_SUB_BRIGH_ADJ:     // Public <Brightness> adj     
 505   2                  MBrightAdjProc();            
 506   2                  break;
 507   2              case MENU_SUB_CONTRAST_ADJ:  // Public <Contrast> adj     
 508   2                  MContrastAdjProc();          
 509   2                  break;
 510   2      #if(_VIDEO_SUPPORT)
 511   2              case MENU_AV_SATURATION_ADJ: // Video <Saturation> adj   
 512   2                  MAVSaturationAdjProc();      
 513   2                  break;
 514   2              case MENU_AV_HUE_ADJ:        // Video <Hue> adj      
 515   2                  MAVHueAdjProc();             
 516   2                  break;
 517   2      #endif
 518   2      
 519   2      
 520   2              //----------------------- VGA Picture adj proc -------------------
 521   2      #if(_VGA_SUPPORT)
 522   2              case MENU_SUB_PHASE_ADJ:     // VGA <Phase> adj     
 523   2                  MPhaseAdjProc();        
 524   2                  break;
 525   2              case MENU_SUB_CLOCK_ADJ:     // VGA <Clock> adj    
 526   2                  MClockAdjProc();        
 527   2                  break;
 528   2              case MENU_SUB_HPOS_ADJ:      // VGA <H position> adj    
 529   2                  MHPosAdjProc();         
 530   2                  break;
 531   2              case MENU_SUB_VPOS_ADJ:      // VGA <V position> adj    
 532   2                  MVPosAdjProc();         
 533   2                  break;
 534   2      #endif
 535   2      
 536   2              //---------------------- TV function adj proc --------------------
 537   2      #if(_VIDEO_TV_SUPPORT)
 538   2              case MENU_AUTO_SEARCH_ADJ:   // TV <Auto search> adj     
 539   2                  MAutoSearchAdjProc();        
 540   2                  break;
 541   2              case MENU_MANUAL_SEARCH_ADJ: // TV <Manual search> adj    
 542   2                  MManualSearchAdjProc();      
 543   2                  break;
 544   2              case MENU_TUNING_ADJ:        // TV <Tunning> adj    
 545   2                  MTuningAdjProc();            
 546   2                  break;
 547   2              case MENU_TV_SYSTEM_ADJ:     // TV <TV system> adj    
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 10  

 548   2                  MTVSystemAdjProc();          
 549   2                  break;
 550   2       //       case MENU_SOUND_SYSTEM_ADJ:  // TV <Sound system> adj <Not use>     
 551   2         //         MSoundSystemAdjProc();       
 552   2           //       break;
 553   2              case MENU_CHANNEL_ADJ:       // TV <Channel> adj    
 554   2         #if(_KEY_TYPE_OSD007== _5KEY_SUPPORT)//0228 guo
                       case MENU_CHANEL_SP:
                 #endif
 557   2                  MChannelAdjProc();           
 558   2                  break;
 559   2              case MENU_SWAP_ADJ:          // TV <Swap> adj      
 560   2                  MSwapAdjProc();               
 561   2                  break;
 562   2              case MENU_SKIP_ADJ:          // TV <Skip> adj    
 563   2                  MSkipAdjProc();              
 564   2                  break;
 565   2      #endif
 566   2      
 567   2              //----------------------- Public OSD adj proc ---------------------
 568   2              case MENU_SUB_OSDLANGUAGE_ADJ:   // Public <Language> adj 
 569   2                  MLanguageAdjProc();     
 570   2                  break;
 571   2      #if(_OSD_POSITION_ADJ_CTRL)
                      case MENU_SUB_OSDH_POSITION_ADJ: // Public <OSD H position> adj
                          MOSDHPositionAdjProc(); 
                          break;
                      case MENU_SUB_OSDV_POSITION_ADJ: // Public <OSD V position> adj
                          MOSDVPositionAdjProc(); 
                          break;
              #endif
 579   2      #if(_OSD_TIMEOUT_ADJ_CTRL)
                      case MENU_SUB_OSD_TIMEOUT_ADJ:   // Public <OSD timeout> adj
                          MOSDTimeoutAdjProc();   
                          break;
              #endif
 584   2      #if(_ALPHA_BLENDING_ADJ)
                      case MENU_SUB_OSD_TRANS_ADJ:    // Public <OSD Translucent> adj
                          MOSDTranslucentAdjProc();   
                          break;
              #endif
 589   2      #if(_OSD_DISPLAY_SIZE_ADJ)
 590   2      if(Panel.DHWidth>1024||Panel.DVHeight>768)
 591   2              {
 592   3              case MENU_SUB_OSD_SIZE_ADJ:    // Public <OSD Size> adj
 593   3                  MOSDSizeAdjProc();   
 594   3                  break;
 595   3              }
 596   2      #endif
 597   2      
 598   2              #if(_DISPLAY_SIZE_ADJ)
 599   2               if(Panel.DHWidth > (Panel.DVHeight * 4/3)) 
 600   2                      {
 601   3                        case MENU_SUB_DISPMODE_ADJ:    // Public <OSD Size> adj
 602   3                        MDispModeAdjProc();   
 603   3                        break;
 604   3                      }
 605   2              #endif
 606   2              //---------------------- Public Ohter adj proc --------------------
 607   2      #if(_BLUE_BACKGROUND_FUNC == _ENABLE)
 608   2              case MENU_BLUE_ADJ:              // Public <Blue> adj 
 609   2                  MBlueAdjProc();              
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 11  

 610   2                  break;
 611   2      #endif
 612   2      
 613   2      #if(_AUTO_POWER_DOWN)
 614   2              case MENU_AUTO_POWER_DOWN_ADJ:   // Public <Auto power down> adj
 615   2                  MAutoPowerDownAdjProc();     
 616   2                  break;
 617   2      #endif
 618   2      
 619   2      #if(_IMAGE_COLOR_MODE)
 620   2              case MENU_COLOR_MODE_ADJ:        // Public <Color mode> adj
 621   2                  MColorModeAdjProc();
 622   2                  break;
 623   2      #endif
 624   2      
 625   2      #if(_SHARPNESS_ADJ)
                      case MENU_SHARP_ADJ:             // Public <Sharp> adj
                          MSharpAdjProc();
                          break;
              #endif
 630   2      
 631   2              //--------------------- Public Sound adj porc ---------------------
 632   2              case MENU_SUB_VOL_ADJ:           // Public <Volume> adj
 633   2              case MENU_VOLUME_SP:
 634   2                  MVolumeAdjProc();            
 635   2                  break;
 636   2              case MENU_SUB_MUTE_ADJ:          // Public <Mute> adj
 637   2                  MMuteAdjProc();              
 638   2                  break;
 639   2      #if(_SOUND_PROCESSOR == _ENABLE)
                      case MENU_SUB_BALANCE_ADJ:       // Public <Balance> adj
                          MBalanceAdjProc();           
                          break;
                      case MENU_SUB_BASS_ADJ:          // Public <Bass> adj
                          MBassAdjProc();              
                          break;
                      case MENU_SUB_TREBLE_ADJ:        // Public <Treble> adj
                          MTrebleAdjProc();            
                          break;
                      case MENU_SUB_SRS_ADJ:           // Public <SRS> adj
                          MSRSAdjProc();               
                          break;
                      case MENU_SUB_BBE_ADJ:           // Public <BBE> adj
                          MBBEAdjProc();               
                          break;
              #endif
 656   2      
 657   2              //------------------ TV Input ch number adj proc -----------------
 658   2      #if(_VIDEO_TV_SUPPORT)
 659   2         #if(_IR_ENABLE)        
 660   2              case ITEM_SHORTCUT_INPUTCH_NUM:  
 661   2      #if(_INPUT_NUMBER_MODE==DirectnessInputNumber)
                      SDirectnessInputCHNumber();
              #endif  
 664   2      
 665   2      #if(_INPUT_NUMBER_MODE==IndirectInputNumber)                    
 666   2                              SInputCHNumber();    
 667   2      #endif        
 668   2                         break;
 669   2         #endif        
 670   2      #endif
 671   2      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 12  

 672   2      
 673   2              //======================== Peaking coring function =====================
 674   2      #if(_VGA_COLOR_SUPPORT)
                      //---------------------- Vivid color item ------------------------
                      case MENU_SAC_DCC_TEXT:               // DCC <Text>
                      case MENU_SAC_DCC_MOVIE:              // DCC <Movie>
                      case MENU_SAC_DCC_GRAPHIC:            // DCC <Graphic>
                      case MENU_SAC_DCC_GAME:               // DCC <Game>
                      case MENU_SAC_DCC_NORMAL:             // DCC <Normal>
                      case MENU_SAC_DCC_USER:               // DCC <User>
                      case MENU_SAC_DCC_CLOSE:              // DCC <Exit>
                          MVividColorItemProc();
                          break;
                  
                      //---------------------- Vivid color sub item --------------------
                      case MENU_USER_ITEM_DCC:              // Vivid Color <DCC>
                      case MENU_USER_ITEM_ICM:              // Vivid Color <ICM>
                      case MENU_USER_ITEM_COLOR:            // Vivid Color <Color>
                      case MENU_USER_ITEM_CLOSE:            // Vivid Color <Exit>
                          MVividColorSubProc();
                          break;
                     
                      //--------------------- Vivid color DCC adj ---------------------
                      case MENU_DCC_ITEM_TEXT:              // DCC <Text>
                      case MENU_DCC_ITEM_MOVIE:             // DCC <Movie>
                      case MENU_DCC_ITEM_GRAPHIC:           // DCC <Graphic>
                      case MENU_DCC_ITEM_GAME:              // DCC <Game>
                      case MENU_DCC_ITEM_NORMAL:            // DCC <Normal>
                          MDCCAdjProc();
                          break;
                  
                      //--------------------------- ICM item ---------------------------
                      case MENU_ICM_ITEM_RED:               // ICM <Red>
                      case MENU_ICM_ITEM_GREEN:             // ICM <Green>
                      case MENU_ICM_ITEM_BLUE:              // ICM <Blue>
                      case MENU_ICM_ITEM_YELLOW:            // ICM <Yellow>
                      case MENU_ICM_ITEM_CYAN:              // ICM <Cyan>
                      case MENU_ICM_ITEM_MAGENTA:           // ICM <Magenta>
                      case MENU_ICM_ITEM_ON_OFF:            // ICM <ICM>
                      case MENU_ICM_ITEM_CLOSE:             // ICM <Exit>
                          MICMItemProc();
                          break;
                  
                      //------------------------ ICM R/G/B item ------------------------
                      case MENU_ICM_SUB_R_HUE:              // ICM R <Hue>
                      case MENU_ICM_SUB_R_SAT:              // ICM R <Saturation>
                      case MENU_ICM_SUB_R_CLOSE:            // ICM R <Close>
                      case MENU_ICM_SUB_G_HUE:              // ICM G <Hue>
                      case MENU_ICM_SUB_G_SAT:              // ICM G <Saturation>
                      case MENU_ICM_SUB_G_CLOSE:            // ICM G <Close>
                      case MENU_ICM_SUB_B_HUE:              // ICM B <Hue>
                      case MENU_ICM_SUB_B_SAT:              // ICM B <Saturation>
                      case MENU_ICM_SUB_B_CLOSE:            // ICM B <Close>
                      case MENU_ICM_SUB_Y_HUE:              // ICM Y <Hue>
                      case MENU_ICM_SUB_Y_SAT:              // ICM Y <Saturation>
                      case MENU_ICM_SUB_Y_CLOSE:            // ICM Y <Close>
                      case MENU_ICM_SUB_C_HUE:              // ICM C <Hue>
                      case MENU_ICM_SUB_C_SAT:              // ICM C <Saturation>
                      case MENU_ICM_SUB_C_CLOSE:            // ICM C <Close>
                      case MENU_ICM_SUB_M_HUE:              // ICM M <Hue>
                      case MENU_ICM_SUB_M_SAT:              // ICM M <Saturation>
                      case MENU_ICM_SUB_M_CLOSE:            // ICM M <Close>
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 13  

                          MICMSubRGBItemAdjProc();
                          break;
                  
                      //-------------------- ICM R/G/B color adj page --------------------
                      case MENU_ICM_R_HUE_ADJ:              // ICM R adj <Hue>
                      case MENU_ICM_R_SAT_ADJ:              // ICM R adj <Saturation>
                      case MENU_ICM_G_HUE_ADJ:              // ICM G adj <Hue>
                      case MENU_ICM_G_SAT_ADJ:              // ICM G adj <Saturation>
                      case MENU_ICM_B_HUE_ADJ:              // ICM B adj <Hue>
                      case MENU_ICM_B_SAT_ADJ:              // ICM B adj <Saturation>
                      case MENU_ICM_Y_HUE_ADJ:              // ICM Y adj <Hue>
                      case MENU_ICM_Y_SAT_ADJ:              // ICM Y adj <Saturation>
                      case MENU_ICM_C_HUE_ADJ:              // ICM C adj <Hue>
                      case MENU_ICM_C_SAT_ADJ:              // ICM C adj <Saturation>
                      case MENU_ICM_M_HUE_ADJ:              // ICM M adj <Hue>
                      case MENU_ICM_M_SAT_ADJ:              // ICM M adj <Saturation>
                          MICMSubRGBColorAdjProc();
                          break;
                     
                      //-------------------------- Vivid color ---------------------------
                      case MENU_COLOR_ITEM_BRIGHTNESS:      // Color <Brightness>
                      case MENU_COLOR_ITEM_CONTRAST:        // Color <Contrast>
                      case MENU_COLOR_ITEM_PEAKING:         // Color <Peaking>
                      case MENU_COLOR_ITEM_CLOSE:           // Color <Exit>
                          MDCCColorAdjProc();
                          break;
                  
                      //------------------ Vivid bright/Contrast adj proc ----------------
                      case MENU_COLOR_ITEM_BRIGHT_ADJ:      // Color adj <Brightness>
                      case MENU_COLOR_ITEM_CON_ADJ:         // Color adj <Contrast>
                      case MENU_COLOR_ITEM_PEAK_ADJ:        // Color adj <Peaking>
                          MDCCColorBCAdjProc();
                          break;
              #endif
 768   2          
 769   2      #if(_IMAGE_COLOR_MODE)//0228 guo
 770   2              case MENU_IMAGE_ADJ:
 771   2                  MImageAdj();
 772   2                  break;
 773   2      #endif
 774   2      #if(_AUTO_POWER_DOWN)
 775   2              case SLEEP_TIME_ADJ:
 776   2                  MSleepTimeAdj();
 777   2                  break;
 778   2      #endif
 779   2              default:                              break;
 780   2                  
 781   2          }    
 782   1      
 783   1      
 784   1      
 785   1      }
 786          
 787          //-----------------------------------------------------------
 788          void MPubNoneProc(void)
 789          {
 790   1          switch(_GET_INPUT_SOURCE())
 791   1          {
 792   2      #if(_TMDS_SUPPORT || _VGA_SUPPORT || _YPBPR_SUPPORT || _HDMI_SUPPORT)
 793   2          case _SOURCE_YPBPR:
 794   2          case _SOURCE_VGA:
 795   2          case _SOURCE_DVI:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 14  

 796   2          case _SOURCE_HDMI:
 797   2              MNoneProc();
 798   2              break;
 799   2      #endif    
 800   2              
 801   2      #if(_VIDEO_SUPPORT)
 802   2      #if(_VIDEO_YUV_SUPPORT)
                  case _SOURCE_VIDEO_YUV:
              #endif
 805   2      #if(DVD_EN)
 806   2          case _SOURCE_VIDEO_DVD:
 807   2      #endif
 808   2          case _SOURCE_VIDEO_AV:
 809   2          case _SOURCE_VIDEO_SV:
 810   2          case _SOURCE_VIDEO_SCART:
 811   2              MAVNoneProc();
 812   2              break;
 813   2      #endif    
 814   2             
 815   2      #if(_VIDEO_TV_SUPPORT)
 816   2          case _SOURCE_VIDEO_TV:
 817   2              MTVNoneProc();
 818   2              break;
 819   2      #endif
 820   2          }
 821   1               
 822   1          if (_MENU_NONE == ucOsdState && _NONE_MSG == ucOsdEventMsg)// && GET_MUTE_STATE() == STATE_MUTEON && u
             -cOsdState != MENU_SHOW_MUTE_STATE)
 823   1          {
 824   2      #if(_IR_ENABLE)        
 825   2        #if(_VIDEO_TV_SUPPORT)
 826   2              if (GET_MUTE_STATE() == STATE_MUTEON && ucOsdState != MENU_SHOW_MUTE_STATE && !bChangeChannel)
 827   2        #else
                      if (GET_MUTE_STATE() == STATE_MUTEON && ucOsdState != MENU_SHOW_MUTE_STATE)
                #endif
 830   2                 DrawMuteState();
 831   2      #else
                      if (0)
                      {
                      }
              #endif // end #if(_IR_ENABLE)
 836   2      #if(_AUTO_POWER_DOWN)
 837   2              else if(0xff != ucAutoPowerDownTime && 0 != _GET_POWER_DOWN_TIME())
 838   2                 CShowTimer(); // Show auto power down timer
 839   2      #endif
 840   2      
 841   2      #if(_LOGO_EN && _LOGO_TYPE == _LOGO_TYPE1)
                      else if (ucCurrState == _ACTIVE_STATE)
                      {
                          CLogoGo(); 
                      }
              #endif
 847   2          } 
 848   1      }
 849          
 850          
 851          //-----------------------------------------------------------
 852          void COthterKeyAction(void)
 853          {
 854   1          if (_NONE_KEY_MESSAGE != ucKeyMessage)
 855   1          {
 856   2              switch(ucKeyMessage)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 15  

 857   2              {
 858   3      #if(_IR_ENABLE)        
 859   3        #if(_USE_UD_LR_KEY_MSG)
 860   3                  case VK_F_LEFT:
 861   3                  case VK_F_RIGHT:
 862   3                  case VK_F_UP:
 863   3                  case VK_F_DOWN:
 864   3        #endif
 865   3                  case VK_MENU:
 866   3                  case _IR_MENU_KEY_MESSAGE:
 867   3                  case VK_IR_DISPLAY:
 868   3                  case VK_IR_MUTE:
 869   3                  case VK_IR_VOLDEC:
 870   3                  case VK_IR_VOLINC:
 871   3      #if(_AUTO_POWER_DOWN)
 872   3                      case VK_IR_SLEEP:
 873   3      #endif              
 874   3                      break;
 875   3      //0228 guo
 876   3                  case _IR_IMAGE_KEY_MESSAGE:
 877   3                      if (_GET_INPUT_SOURCE() == _SOURCE_VGA)
 878   3                         return;
 879   3                      else
 880   3                         break;
 881   3                  case VK_IR_CHINC:
 882   3                  case VK_IR_CHDEC:
 883   3                  case VK_IR_NUM0:
 884   3                  case VK_IR_NUM1:
 885   3                  case VK_IR_NUM2:
 886   3                  case VK_IR_NUM3:
 887   3                  case VK_IR_NUM4:
 888   3                  case VK_IR_NUM5:
 889   3                  case VK_IR_NUM6:
 890   3                  case VK_IR_NUM7:
 891   3                  case VK_IR_NUM8:
 892   3                  case VK_IR_NUM9:
 893   3      #if(_INPUT_NUMBER_MODE!=DirectnessInputNumber)                          
 894   3                  case VK_IR_INPUTCH:
 895   3      #endif                          
 896   3                  case VK_IR_RETURN:
 897   3                      if (_SOURCE_VIDEO_TV != _GET_INPUT_SOURCE())  // TV key
 898   3                          return;
 899   3          
 900   3                      break;
 901   3      #endif
 902   3                  default:
 903   3                      return;
 904   3              }
 905   2      
 906   2              CLR_KEYREPEATENABLE();
 907   2              ucOsdState = _MENU_NONE;
 908   2              bRCallOSD  = 1;
 909   2             // COsdProc();
 910   2          }
 911   1      }
 912          
 913          //------------------------------------------------------------
 914          void MPublicNoneMenu(void)
 915          {           
 916   1          InitOSDFrame();
 917   1          CDrawColorPage();
 918   1          ucOsdState = MENU_MAIN_COLOR;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 16  

 919   1          CShowSelectMainItemWindow(_FIRST_ITEM);
 920   1      
 921   1          COsdFxEnableOsd();
 922   1      }
 923          
 924          //------------------------------------------------------------
 925          void MMainItemProc(void)
 926          {
 927   1          switch(ucKeyMessage)
 928   1          {
 929   2              //  Select item
 930   2      #if(_USE_UD_LR_KEY_MSG)
 931   2              case VK_F_UP:
 932   2              case VK_F_DOWN:
 933   2      #endif
 934   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_MENU:       
              #endif
 937   2              case VK_IR_OK:       
 938   2                              MMainItemMenu();       break;
 939   2      
 940   2              // Move item
 941   2      #if(_USE_UD_LR_KEY_MSG)
 942   2              case VK_F_LEFT:
 943   2      #endif
 944   2              case VK_LEFT:        MMainItemLR(1);        break;
 945   2              // Move item
 946   2      #if(_USE_UD_LR_KEY_MSG)
 947   2              case VK_F_RIGHT:
 948   2      #endif
 949   2              case VK_RIGHT:       MMainItemLR(0);        break;
 950   2      
 951   2              // Exit item
 952   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
 953   2              case VK_ENTER:   
 954   2      #endif
 955   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
 956   2              case VK_MENU:       
 957   2      #endif
 958   2              case VK_AUTO:
 959   2              case VK_IR_EXIT:
 960   2          COsdFxDisableOsd();    break;
 961   2              // Default
 962   2              default:             COthterKeyAction();    break;
 963   2          }
 964   1      }
 965          
 966          //------------------------------------------------------------
 967          void MMainItemMenu(void)
 968          {       
 969   1          // Enter Sub Item
 970   1          switch(ucOsdState)
 971   1          {
 972   2              case MENU_MAIN_COLOR: 
 973   2                  ucOsdState = MENU_ITEM_BRIGHT;      
 974   2                  break;
 975   2      
 976   2      #if(_VGA_SUPPORT || _YPBPR_SUPPORT)
 977   2              case MENU_MAIN_PICTURE:
 978   2                  ucOsdState= MENU_ITEM_AUTO;      
 979   2                  break;
 980   2      #endif
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 17  

 981   2                  
 982   2      #if(_VIDEO_TV_SUPPORT)
 983   2              case MENU_MAIN_TV_FUNC:
 984   2                  ucOsdState= MENU_AUTO_SEARCH;      
 985   2                  break;
 986   2      #endif
 987   2                  
 988   2              case MENU_MAIN_OSD_FUNC:
 989   2                  ucOsdState= MENU_SUB_LANGUAGE;      
 990   2                  break;
 991   2      
 992   2              case MENU_MAIN_SOUND:
 993   2                  ucOsdState= MENU_SUB_VOLUME;      
 994   2                  break;
 995   2      
 996   2              case MENU_MAIN_OTHER:
 997   2                  ucOsdState= MENU_SUB_RESET;      
 998   2                  break;
 999   2      
1000   2              case MENU_MAIN_EXIT:
1001   2                  COsdFxDisableOsd();
1002   2      //                      ucOsdState = MENU_SUB_EXIT_CLOSE;
1003   2                  break;
1004   2      
1005   2          }
1006   1      
1007   1          CSetItemWindowState(_SELECT_MAIN_WINDOW, _SELECT_STATE);
1008   1          CShowSubItemWindow(_FIRST_ITEM);
1009   1      }
1010          
1011          //------------------------------------------------------------
1012          void MMainItemLR(BYTE  LR)
1013          {  
1014   1          BYTE ucTemp = 0;
1015   1      
1016   1          CClearSubItem();
1017   1      
1018   1          if(LR)
1019   1          {     
1020   2              switch(ucOsdState)
1021   2              {
1022   3                  case MENU_MAIN_COLOR:
1023   3                      switch(_GET_INPUT_SOURCE())
1024   3                      {
1025   4      #if(_VGA_SUPPORT || _YPBPR_SUPPORT)
1026   4                          case _SOURCE_VGA:
1027   4                          case _SOURCE_YPBPR:
1028   4                              ucOsdState = MENU_MAIN_PICTURE;      
1029   4                              break;
1030   4      #endif
1031   4      
1032   4                          case _SOURCE_DVI:
1033   4                          case _SOURCE_HDMI:
1034   4                          case _SOURCE_VIDEO_AV:
1035   4                          case _SOURCE_VIDEO_SV:
1036   4                         #if(DVD_EN)
1037   4                             case _SOURCE_VIDEO_DVD:
1038   4                         #endif
1039   4                          case _SOURCE_VIDEO_SCART:
1040   4                              ucOsdState = MENU_MAIN_OSD_FUNC;      
1041   4                              break;
1042   4      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 18  

1043   4      #if(_VIDEO_TV_SUPPORT)
1044   4                          case _SOURCE_VIDEO_TV:
1045   4                              ucOsdState = MENU_MAIN_TV_FUNC;      
1046   4                              break;
1047   4      #endif
1048   4                      }
1049   3                      break;
1050   3      
1051   3                  case MENU_MAIN_PICTURE:        
1052   3                  case MENU_MAIN_TV_FUNC:        ucOsdState = MENU_MAIN_OSD_FUNC;     break;
1053   3                  case MENU_MAIN_OSD_FUNC:       ucOsdState = MENU_MAIN_SOUND;        break;
1054   3                  case MENU_MAIN_SOUND:          ucOsdState = MENU_MAIN_OTHER;        break;
1055   3                  case MENU_MAIN_OTHER:          ucOsdState = MENU_MAIN_EXIT;         break;
1056   3                  case MENU_MAIN_EXIT:           ucOsdState = MENU_MAIN_COLOR;        break;
1057   3              }  
1058   2          }
1059   1          else
1060   1          {
1061   2              switch(ucOsdState)
1062   2              {
1063   3                  case MENU_MAIN_COLOR:          ucOsdState = MENU_MAIN_EXIT;         break;
1064   3                  case MENU_MAIN_PICTURE:
1065   3                  case MENU_MAIN_TV_FUNC:        ucOsdState = MENU_MAIN_COLOR;        break;
1066   3                  case MENU_MAIN_OSD_FUNC:       
1067   3                      switch(_GET_INPUT_SOURCE())
1068   3                      {
1069   4      #if(_VGA_SUPPORT || _YPBPR_SUPPORT || _HDMI_SUPPORT)
1070   4                          case _SOURCE_VGA:
1071   4                          case _SOURCE_YPBPR:
1072   4                              ucOsdState = MENU_MAIN_PICTURE;      
1073   4                              break;
1074   4      #endif
1075   4      
1076   4                          case _SOURCE_DVI:
1077   4                          case _SOURCE_HDMI:
1078   4                          case _SOURCE_VIDEO_AV:
1079   4                          case _SOURCE_VIDEO_SV:
1080   4                        //  case _SOURCE_VIDEO_YUV:
1081   4                            #if(DVD_EN)
1082   4                                 case _SOURCE_VIDEO_DVD:
1083   4                            #endif
1084   4                          case _SOURCE_VIDEO_SCART:
1085   4                              ucOsdState = MENU_MAIN_COLOR;      
1086   4                              break;
1087   4      
1088   4      #if(_VIDEO_TV_SUPPORT)
1089   4                          case _SOURCE_VIDEO_TV:
1090   4                              ucOsdState = MENU_MAIN_TV_FUNC;      
1091   4                              break;
1092   4      #endif
1093   4                      }
1094   3                      break;            
1095   3      
1096   3                  case MENU_MAIN_SOUND:          ucOsdState = MENU_MAIN_OSD_FUNC;     break;
1097   3                  case MENU_MAIN_OTHER:          ucOsdState = MENU_MAIN_SOUND;        break;
1098   3                  case MENU_MAIN_EXIT:           ucOsdState = MENU_MAIN_OTHER;        break;
1099   3              }
1100   2          }
1101   1          
1102   1          if (_GET_INPUT_SOURCE() == _SOURCE_VIDEO_AV       || _GET_INPUT_SOURCE() == _SOURCE_VIDEO_SV
1103   1                || _GET_INPUT_SOURCE() == _SOURCE_VIDEO_YUV || _GET_INPUT_SOURCE() == _SOURCE_DVI
1104   1                || _GET_INPUT_SOURCE() == _SOURCE_HDMI      || _GET_INPUT_SOURCE() == _SOURCE_VIDEO_SCART)  // e
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 19  

             -ric 0718
1105   1              ucTemp = 1; 
1106   1          else
1107   1              ucTemp = 0;
1108   1      
1109   1          switch(ucOsdState)
1110   1          {
1111   2              case MENU_MAIN_COLOR:
1112   2                  CDrawColorPage();
1113   2                  ucTemp = 0;
1114   2                  break;
1115   2      
1116   2      #if(_VGA_SUPPORT || _YPBPR_SUPPORT)
1117   2              case MENU_MAIN_PICTURE:
1118   2                  CDrawPicturePage();
1119   2                  ucTemp = 1;
1120   2                  break;
1121   2      #endif
1122   2      
1123   2      #if(_VIDEO_TV_SUPPORT)
1124   2              case MENU_MAIN_TV_FUNC:
1125   2                  CDrawTVFunction();
1126   2                  ucTemp = 1;
1127   2                  break;
1128   2      #endif
1129   2      
1130   2              case MENU_MAIN_OSD_FUNC:
1131   2                  CDrawOSDFuncPage();
1132   2      
1133   2                  if (ucTemp)
1134   2                     ucTemp = 1;
1135   2                  else
1136   2                     ucTemp = 2;
1137   2                  break;
1138   2      
1139   2              case MENU_MAIN_SOUND:
1140   2                  CDrawSoundPage();
1141   2                  if (ucTemp)
1142   2                     ucTemp = 2;
1143   2                  else
1144   2                     ucTemp = 3;
1145   2                  break;
1146   2      
1147   2              case MENU_MAIN_OTHER:
1148   2                  CDrawOtherFuncPage();
1149   2                  if (ucTemp)
1150   2                     ucTemp = 3;
1151   2                  else
1152   2                     ucTemp = 4;
1153   2                  break;
1154   2      
1155   2              case MENU_MAIN_EXIT:
1156   2                  CDrawExitPage();
1157   2                  if (ucTemp)
1158   2                     ucTemp = 4;
1159   2                  else
1160   2                     ucTemp = 5;
1161   2                  break;
1162   2          }   
1163   1          
1164   1          CShowSelectMainItemWindow(ucTemp);
1165   1      }
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 20  

1166          
1167          //-----------------------------------------------------------
1168          void COsdDispFirstTimeLoadFont(void)
1169          {    
1170   1          //Before First Time Load Font Disable OSD
1171   1          COsdFxDisableOsd();
1172   1          
1173   1          //Load Public Fonts
1174   1          SetOSDRamAddress(ROW_COUNT,COL_WIDTH,FONT_BASE_ADDRESS);
1175   1          
1176   1      #if(_HARDWARE_LOAD_FONT == _ON)
              
                  CScalerLoadHardwareVLCFont(tFntGlobal, 0x00);
                  
                  // Load 4 bit icon
                  CScalerLoadHardwareVLCFont(tFntIcon4Bit, (_4BIT_ICON_COLOR_ADDR*4));  // icon
                  if (_SOURCE_VIDEO_TV == _GET_INPUT_SOURCE())
                      CScalerLoadHardwareVLCFont(tFntIcon4BitTvFunc, (_4BIT_ICON_TV_FUNC_ADDR*4));  // TV function icon
              
              #else
1186   1      
1187   1          CScalerLoadFont(tFntGlobal,0x00,0x7B,_COMPRESS_FONT);
1188   1          
1189   1          // Load 4 bit icon
1190   1          CScalerLoadFont(tFntIcon4Bit, (_4BIT_ICON_COLOR_ADDR*4), (6*_4BIT_ICON_SIZE*4), _COMPRESS_FONT);  // i
             -con
1191   1          if (_SOURCE_VIDEO_TV == _GET_INPUT_SOURCE())
1192   1              CScalerLoadFont(tFntIcon4BitTvFunc, (_4BIT_ICON_TV_FUNC_ADDR*4), (_4BIT_ICON_SIZE*4), _COMPRESS_FO
             -NT);  // TV function icon
1193   1      
1194   1      #endif
1195   1      
1196   1          //Load Languege Font
1197   1          LoadLanguageFont();
1198   1      }
1199          //-----------------------------------------------------------
1200          void LoadLanguageFont()
1201          {   
1202   1          switch(GET_LANGUAGE)
1203   1          {
1204   2          case LNG_CHI_S:
1205   2      #if(LNG_CHI_S_EN == 1)
1206   2      #if(_HARDWARE_LOAD_FONT == _ON)
              
                      CScalerLoadHardwareVLCFont(tFntChiPublic, 0x7B);
                      CScalerLoadHardwareVLCFont(tFntChi_S, 0xA8);
              
              #else
1212   2      
1213   2              CScalerLoadFont(tFntChiPublic, 0x7B, 45, _COMPRESS_FONT);
1214   2              CScalerLoadFont(tFntChi_S, 0xA8, 45, _COMPRESS_FONT);
1215   2      
1216   2      #endif
1217   2      #endif
1218   2              break;
1219   2      
1220   2      #if(LNG_ARABIC_EN)
                   case LNG_ARABIC:
                      CScalerLoadFont(tFntARABIC, 0x7B, 60, _COMPRESS_FONT);
                      break;
              #endif
1225   2      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 21  

1226   2          case LNG_CHI_T:
1227   2      #if(LNG_CHI_T_EN == 1)
1228   2      #if(_HARDWARE_LOAD_FONT == _ON)
              
                      CScalerLoadHardwareVLCFont(tFntChiPublic, 0x7B);
                      CScalerLoadHardwareVLCFont(tFntChi_T, 0xa8);
              
              #else
1234   2      
1235   2              CScalerLoadFont(tFntChiPublic, 0x7B, 45, _COMPRESS_FONT);
1236   2              CScalerLoadFont(tFntChi_T, 0xa8, 45, _COMPRESS_FONT);
1237   2      
1238   2      #endif
1239   2      #endif
1240   2              break;
1241   2      #if(LNG_RUSS_EN)
1242   2              case LNG_RUSS:
1243   2                      CScalerLoadFont(tFntRuss, 0x7B, 64, _COMPRESS_FONT);
1244   2                      break;
1245   2      #endif
1246   2                      
1247   2      #if(LNG_KOREAN_EN )
                      case LNG_KOREAN:
                              CScalerLoadFont(tFntKorean, 0x80,82, _COMPRESS_FONT);
                              break;
              #endif          
1252   2      
1253   2          }  
1254   1      }
1255          //-----------------------------------------------------------
1256          void COsdDispOsdTimerEvent(void)
1257          {
1258   1          COsdFxDisableOsd();
1259   1      }
1260          
1261          //-----------------------------------------------------------
1262          void COsdEventMsgProc(void)
1263          {
1264   1          switch(ucOsdEventMsg)
1265   1          {
1266   2          case _SHOW_NOSIGNAL_MSG:
1267   2          case _SHOW_NOCABLE_MSG:
1268   2          case _SHOW_NOSUPPORT_MSG:
1269   2             ucOsdState = 0;
1270   2      #if(_BURNIN_EN)
1271   2               if(GET_BURNIN_STATE()==BURNIN_ON)
1272   2                      {
1273   3                         CTimerCancelTimerEvent(CModePowerSavingEvent);                               
1274   3                        InitBurnIn();
1275   3                      }
1276   2                       else
1277   2      #endif    
1278   2               if(GET_BURNIN_STATE()!=BURNIN_ON)
1279   2              {
1280   3              MUTE_ON();
1281   3              HintDialog();
1282   3              }        break;
1283   2              
1284   2          case _SAVE_EE_MODEUSERDATA_MSG:
1285   2              CEepromSaveModeData(stModeInfo.ModeCurr);
1286   2              break;
1287   2              
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 22  

1288   2          case _SAVE_EE_SYSTEMDATA_MSG:
1289   2              CEepromSaveSystemData();
1290   2              break;
1291   2              
1292   2          case _SAVE_EE_OSDUSERDATA_MSG:
1293   2              CEepromSaveOsdUserData();
1294   2              break;
1295   2              
1296   2          case _SAVE_EE_ADCDATA_MSG:
1297   2              CEepromSaveAdcData();
1298   2              break;
1299   2              
1300   2          case _SAVE_EE_BriConHueSat_MSG:
1301   2              CEepromSaveBriConData();
1302   2              break;
1303   2              
1304   2          case _SAVE_EE_COLORPROC1_MSG:
1305   2              CEepromSaveColorTempData();
1306   2              break;
1307   2      #if(_VIDEO_SUPPORT)
1308   2          case _SAVE_EE_VEDIOCOLOR_MSG:
1309   2              CEepromSaveVedioColor();
1310   2              break;
1311   2      #endif
1312   2          case _ENTER_FACTORY_MODE_MSG:
1313   2              //stOsdUserData.OsdSettingFlag |= _BIT7;
1314   2              break;
1315   2              
1316   2          case _CHANGE_SOURCE_MSG:
1317   2                  CModeResetMode();
1318   2                      CLR_SOURCE_AUTOCHANGE();
1319   2                      CEepromSaveSystemData();
1320   2                    ShowNote();
1321   2                 // CPowerLightPowerOn();
1322   2                // SET_FIRST_SHOW_NOTE();
1323   2              ucCurrState = _SEARCH_STATE;
1324   2              break;
1325   2              
1326   2          case _DO_AUTO_CONFIG:
1327   2      #if(_VGA_SUPPORT)
1328   2                    DoAuto();
1329   2      #endif
1330   2              break;   
1331   2              
1332   2          case _DO_SHOW_NOTE:
1333   2              ShowNote();
1334   2              break;
1335   2                      
1336   2          case _BurnInRun_Out:
1337   2                              CScalerSetBit(_VDISP_CTRL_28, ~_BIT5,0x00 );
1338   2                                if (_NOSIGNAL_STATE == ucCurrState||_NOSUPPORT_STATE == ucCurrState) 
1339   2                                      {
1340   3                                      CScalerSetBit(_VDISP_CTRL_28, ~_BIT5,_BIT5 );
1341   3                      CAdjustBackgroundColor(0x00, 0x00, (_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV) ? ((_GET_BLUE
             -_BACKGROUND()) ? 0xFF: 0x00) : 0x00);
1342   3                                      }
1343   2                         if(GET_FAC_STATE()==0)
1344   2                          CEepromSaveOsdUserData();
1345   2                      
1346   2              break;
1347   2                      
1348   2      #if(_INPUT_NUMBER_MODE==DirectnessInputNumber )         
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 23  

                  case _CHANGE_NUMBER_MSG:
                       if(ucPrevChannel !=  stVDCColor.CurrentChannel)
                              {
                     MUTE_ON();
                      ucOsdState = _MENU_NONE;
                      CModeResetTVMode();
                      CTimerDelayXms(200);
                              if(stVDCColor.CurrentChannel>CloadMaxChannelNumber(0))
                                      stVDCColor.CurrentChannel =CloadMaxChannelNumber(0);
                              else
                              if(stVDCColor.CurrentChannel<CloadMinChannelNumber())
                                      stVDCColor.CurrentChannel =CloadMinChannelNumber();
                      CSetTVChannel(stVDCColor.CurrentChannel);
                      SET_OSD_READYFORDISPLAY();
                      gmi_CI2CWrite9886(ucTVType, _TUNER_MUTE_OFF, _NORMAL_MODE);
                      bChangeChannel = 0;
                      CEepromSaveVedioColor();
                              }
                       else
                     CShowTVNumber(stVDCColor.CurrentChannel, _SHOW_CH_TV_NUMBER | _SHOW_CH_TV_TYPE | _SHOW_CH_SOUND_TYP
             -E);  //eric1221 mark
                     break;
              #endif
1371   2      
1372   2          case _FAC_FOR_IN: 
1373   2                        EnterFactoryMenu();
1374   2                        SET_NOSIGNAL_INFO(1);
1375   2              break;
1376   2            
1377   2          default:
1378   2              break;
1379   2          }
1380   1          
1381   1          ucOsdEventMsg = _NONE_MSG;
1382   1      }
1383          
1384          //----------------------------------------------------------------------------------------------------
1385          void ShowMode(void)
1386          {
1387   1          if (ucCurrState == _NOSIGNAL_STATE) 
1388   1              return;
1389   1          
1390   1          switch(_GET_INPUT_SOURCE())
1391   1          {
1392   2          case _SOURCE_VGA:
1393   2          case _SOURCE_DVI:
1394   2          case _SOURCE_HDMI:
1395   2              //display display size
1396   2              Gotoxy(5,_MESSAGE_V_POSITION,0x50);
1397   2              OutputDisplaySize();
1398   2              //display refresh
1399   2              Gotoxy(17,_MESSAGE_V_POSITION,0x50);
1400   2              OutputChar('@');          
1401   2              OutputChar(0x00);            
1402   2              OutputRefrushRate();  
1403   2              break; 
1404   2      
1405   2      #if(_YPBPR_SUPPORT)
                  case _SOURCE_YPBPR:
                      if (stModeInfo.ModeCurr < _MAX_YPBPR_MODE)
                         CenterTextout((BYTE *)sYPbPrMode[stModeInfo.ModeCurr],15,_MESSAGE_V_POSITION);
                      break;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 24  

              #endif
1411   2      
1412   2      #if(_VIDEO_SUPPORT)
1413   2          case _SOURCE_VIDEO_AV:
1414   2          case _SOURCE_VIDEO_SV:
1415   2        //  case _SOURCE_VIDEO_YUV:
1416   2              case _SOURCE_VIDEO_DVD:
1417   2          case _SOURCE_VIDEO_SCART:
1418   2              if(CHECK60HZ())
1419   2                  CenterTextout(sNTSC,14,_MESSAGE_V_POSITION);
1420   2              else
1421   2                  CenterTextout(sPAL,14,_MESSAGE_V_POSITION);
1422   2              break;
1423   2      
1424   2        #if(_VIDEO_TV_SUPPORT) 
1425   2          case _SOURCE_VIDEO_TV:
1426   2      #if(_NTSC_SEARCH_TABLE)
                      CenterTextout((BYTE *)sCATV_AIR[_GET_CATV_AIR()], 14, _MESSAGE_V_POSITION);
              #else
1429   2              CenterTextout((BYTE *)sTVType[ucTVType], 14, _MESSAGE_V_POSITION);
1430   2      #endif
1431   2                      break;
1432   2        #endif
1433   2      #endif
1434   2          }
1435   1      }
1436          
1437          //--------------------------------------------------------------------------------------------------------
             --------------
1438          void OSDSlider(BYTE row, BYTE col, BYTE length, BYTE value, BYTE range,
1439                         BYTE color, bit bMode)
1440          {
1441   1          WORD bound;
1442   1          BYTE i,c;
1443   1          
1444   1          OSDLine(row, col, length + 6, color, THE_BYTE2);   // Set Slider Attribute. 4 extra columns for space/
             -numbers/space
1445   1          bound   = length * value;
1446   1          Gotoxy(col,row,THE_BYTE1);
1447   1          OutputChar(0x21);          // Left Border
1448   1          
1449   1          for (i = 1; i <= length; i++)
1450   1          {
1451   2              if (bound)
1452   2              {
1453   3                  if(bound >= range)
1454   3                  {
1455   4                      c       = 0x28;
1456   4                      bound   = bound - range;
1457   4                  }
1458   3                  else
1459   3                  {
1460   4                      color   = (bound << 4) / range;
1461   4                      bound   = 0;
1462   4                      if (4 > color)                    c = 0x23;
1463   4                      else if (7 > color)               c = 0x24;
1464   4                      else if (10 > color)              c = 0x25;
1465   4                      else if (13 > color)              c = 0x26;
1466   4                      else                              c = 0x27;
1467   4                  }
1468   3              }
1469   2              else
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 25  

1470   2              {
1471   3                  c = 0x22;
1472   3              }
1473   2              OutputChar(c);
1474   2          }
1475   1          OutputChar(0x29);    // Right Border
1476   1          OutputChar(0x00);
1477   1      
1478   1          if (_SHOW_PERCENT == bMode)
1479   1          {
1480   2              CShowNumber(value, 0);    //百分比显示在右边
1481   2              OutputChar(0x2a);
1482   2              if (value < 100)
1483   2                 OutputChar(0x00);
1484   2          }
1485   1      }
1486          
1487          //---------------------------------------------------------------------------
1488          void DispIcon(BYTE x, BYTE y, BYTE ucIconBaseAddr)
1489          {
1490   1          Gotoxy(x, y, BYTE_DISPLAY);
1491   1          
1492   1          pData[0] = ucIconBaseAddr;
1493   1          pData[1] = ucIconBaseAddr + 1;
1494   1          pData[2] = ucIconBaseAddr + 2;
1495   1          CScalerWrite(_OSD_DATA_PORT_92, 3, pData, _NON_AUTOINC);
1496   1          
1497   1          Gotoxy(x, y + 1, BYTE_DISPLAY);
1498   1          pData[0] = ucIconBaseAddr + 3;
1499   1          pData[1] = ucIconBaseAddr + 4;
1500   1          pData[2] = ucIconBaseAddr + 5;
1501   1          CScalerWrite(_OSD_DATA_PORT_92, 3, pData, _NON_AUTOINC);
1502   1      }
1503          //---------------------------------------------------------------------------
1504          
1505          void NotUseFunc()
1506          { 
1507   1       //   SetOSDRamAddress(0,0,0);
1508   1         // DirectWOSDRam(0,0,0,0);
1509   1       //   SetRowCmds(0,0);
1510   1          //  Gotoxy(0,0,0);
1511   1       //   OutputChar(0);
1512   1      //    Textout(0);
1513   1      //    PrintfDec(0);
1514   1          //    OSDPosition(0,0,0,0,0);
1515   1          //  OSDLine(0,0,0,0,0);
1516   1          //    OSDClear(0,0,0, 0,0,0);
1517   1        //  OutputDisplaySize();       //在当前的位置输出显示尺寸
1518   1       //   OutputRefrushRate();       //在当前的位置输出刷新频率
1519   1          //    COsdFxCodeWrite(0);
1520   1          //  COsdFxDisableOsd();
1521   1          //   COsdFxDrawWindow(0,0,0,0,0);
1522   1      //    StrLen(0);
1523   1          //    ValueInRangeChange(0,0,0,0,0);
1524   1        //  CAutoDoAutoConfig();
1525   1          CAutoDoWhiteBalance();
1526   1      #if(_VGA_SUPPORT)
1527   1          DoAuto();
1528   1      #endif
1529   1          //   CEepromSaveOsdUserData();
1530   1          //    CEepromSaveBriConData();
1531   1        //  CEepromSaveColorTempData();
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 26  

1532   1       //   CScalerLoadFont(0, 0, 0, 0);
1533   1          //  ShowMode();
1534   1          //   OSDSlider(0, 0, 0, 0, 0,0);   
1535   1         // GetNextLanguage(0);
1536   1      //    GetPrevLanguage(0);
1537   1        //  CheckLanguage();
1538   1        //  FirstLanguage();
1539   1         //   COsdFxEnableOsd();
1540   1        //  DoReset();
1541   1       //   VPosGuage();
1542   1        //  HPosGuage();
1543   1       //   ClockGuage();
1544   1        //  COsdFxCloseWindow(0);
1545   1      //    GotoAdjustBrightness();
1546   1       //   gmi_CInitial_IR();
1547   1       //   gmi_CStopIR();
1548   1      //    gmi_CStartIR();
1549   1      //    gmi_IR_Delay();
1550   1      //    RightAlignTextOut(0,0,0);
1551   1       //   CShowNumber(0,0);
1552   1       //   CDrawColorPage();
1553   1      //    CDrawOSDFuncPage();
1554   1        //  CDrawSoundPage();
1555   1        //  CDrawOtherFuncPage();
1556   1        //  GetVirtualKey();
1557   1        //  ShowMode();
1558   1        #if(_IR_ENABLE)
1559   1          gmi_IR_Delay();
1560   1        #endif
1561   1      #if(_VIDEO_TV_SUPPORT)
1562   1       //   CTvAutoSearch();
1563   1          gmi_CRead9886();
1564   1      //    gmi_CI2CWriteTuner(pData);
1565   1      #endif
1566   1      
1567   1      #if(_VIDEO_SUPPORT && _VIDEO_CHIP == _VDC_TB1334)
1568   1          gmi_CSetMode(VideoType, _DISPLAY_MODE_4_3, _SCALER_TYPE);  
1569   1          gmi_CVideoSyncHandler();
1570   1          gmi_CVideoModeChange();
1571   1      #endif
1572   1      }
1573          
1574          //----------------------------------------------------------------------------------------------------
1575          void CClearWindow(BYTE ucCharacterColor)
1576          {
1577   1          OSDClear(0, ROW_COUNT, 0, COL_WIDTH, 0x8C, THE_BYTE0);
1578   1          OSDClear(0, ROW_COUNT, 0, COL_WIDTH, 0x00, THE_BYTE1);
1579   1          OSDClear(0, ROW_COUNT, 0, COL_WIDTH, ucCharacterColor, THE_BYTE2);
1580   1      }
1581          
1582          //----------------------------------------------------------------------------------------------------
1583          void CInitOSDMainFrame(void)
1584          {        
1585   1          COsdFxDisableOsd();
1586   1          COsdFxCodeWrite(ucCloseAllWindow);
1587   1          SetOSDRamAddress(ROW_COUNT,COL_WIDTH,FONT_BASE_ADDRESS);
1588   1          SetRowCmds(ROW_COUNT,COL_WIDTH);
1589   1      
1590   1      #if(_ALPHA_BLENDING_ADJ || _OSD_DISPLAY_SIZE_ADJ)
1591   1      if(Panel.DHWidth>1024||Panel.DVHeight>768)
1592   1             CSetOSDTransAndSize();
1593   1      #endif
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 27  

1594   1      
1595   1      #if(_LOGO_EN && _LOGO_TYPE == _LOGO_TYPE1)
                  COsdDispFirstTimeLoadFont();                 
              #endif
1598   1      
1599   1          CClearWindow(0x40);  // Clear window and set character color to black
1600   1      }
1601          
1602          
1603          
1604          //----------------------------------------------------------------------------------------------------
1605          void InitOSDFrame(void)
1606          {    
1607   1          BYTE ucTemp = 0;
1608   1         
1609   1          CInitOSDMainFrame();
1610   1      
1611   1           if (_GET_OSD_SIZE()) 
1612   1              OSDPosition(_OSD_DOUBLE_WIDTH(_MAIN_WINDOW_WIDTH), _OSD_DOUBLE_HEIGHT(_MAIN_WINDOW_HEIGHT), stOsdU
             -serData.OsdHPos+(_MAINMENU_DOUBLE_H_OFFSET), stOsdUserData.OsdVPos+(_MAINMENU_DOUBLE_V_OFFSET), 0x03);
1613   1            else
1614   1              OSDPosition(_MAIN_WINDOW_WIDTH, _MAIN_WINDOW_HEIGHT, stOsdUserData.OsdHPos+(_MAINMENU_H_OFFSET), s
             -tOsdUserData.OsdVPos+(_MAINMENU_V_OFFSET), 0x03);
1615   1          SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
1616   1          // Set item shadow
1617   1      #if(_OSD_SHADOW_FUNC == _ENABLE)
                  DirectWOSDRam(0x04, ROW_COUNT-0x04, THE_BYTE0, (0x80 | 0x18));
              #endif
1620   1      #if(!_OSD_DISPLAY_SIZE_ADJ && !_ALPHA_BLENDING_ADJ)
                  pData[0] = 0x40;
                  pData[1] = 0x03;
                  pData[2] = 0xa0;
                  CScalerWrite(_OSD_ADDR_MSB_90,3,pData,_AUTOINC);
              #else
1626   1      if(Panel.DHWidth<=1024&&Panel.DVHeight<=768)
1627   1              {
1628   2          pData[0] = 0x40;
1629   2          pData[1] = 0x03;
1630   2          pData[2] = 0xa0;
1631   2          CScalerWrite(_OSD_ADDR_MSB_90,3,pData,_AUTOINC);
1632   2              }
1633   1      #endif
1634   1      
1635   1          // Draw window
1636   1          COsdFxDrawWindow(XSTART(_MAIN_WINDOW_H_POS),                  YSTART(_MAIN_WINDOW_V_POS), 
1637   1                           XEND(_MAIN_WINDOW_H_POS+_MAIN_WINDOW_WIDTH), YEND(_MAIN_WINDOW_V_POS+_MAIN_WINDOW_HEI
             -GHT), 
1638   1                           tOSD_MAIN_WINDOW_STYLE);
1639   1      
1640   1          COsdFxDrawWindow(XSTART(_LINE_WINDOW_H_POS),                  YSTART(_LINE_WINDOW_V_POS),
1641   1                           XEND(_LINE_WINDOW_H_POS+_LINE_WINDOW_WIDTH), YEND(_LINE_WINDOW_V_POS+_LINE_WINDOW_HEI
             -GHT), 
1642   1                           tOSD_LINE_WINDOW_STYLE);
1643   1      
1644   1          // Init Char Cmd
1645   1          // Set row 1/2 to 4bit
1646   1          OSDClear(1, 2, 0, COL_WIDTH-1, 0x90, BYTE_ATTRIB);
1647   1      
1648   1          // Set row height to 31, and col space to 0
1649   1          DirectWOSDRam(3, 1, THE_BYTE1, 0xf8); // Row 3
1650   1          // Set row height to 22, and col space to 0
1651   1          DirectWOSDRam(4, 9, THE_BYTE1, 0xb0); // Row 4 ~ (4+9)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 28  

1652   1      
1653   1          // Show 4bit Icon
1654   1          CShow4BitIcon();
1655   1          ShowMode();
1656   1          CLR_KEYREPEATENABLE();
1657   1      
1658   1      }
1659          
1660          //----------------------------------------------------------------------------------------------------
1661          void CShow4BitIcon(void)
1662          {
1663   1          BYTE uctemp;
1664   1      
1665   1          switch(_GET_INPUT_SOURCE())
1666   1          {
1667   2      #if(_VGA_SUPPORT || _YPBPR_SUPPORT)
1668   2          case _SOURCE_VGA:
1669   2          case _SOURCE_YPBPR:
1670   2              for(uctemp = 0; uctemp < 6; uctemp++)
1671   2              {
1672   3                  DispIcon(1+(4*uctemp), 1, _4BIT_ICON_COLOR_ADDR+(uctemp*6));
1673   3              } 
1674   2              break;
1675   2      #endif
1676   2      
1677   2      #if(_TMDS_SUPPORT || _VIDEO_AV_SUPPORT || _VIDEO_SV_SUPPORT || _VIDEO_YUV_SUPPORT || _HDMI_SUPPORT ||DVD_E
             -N)                                    
1678   2          case _SOURCE_DVI:
1679   2          case _SOURCE_HDMI:
1680   2          case _SOURCE_VIDEO_AV:
1681   2          case _SOURCE_VIDEO_SV:
1682   2          //case _SOURCE_VIDEO_YUV:
1683   2         case _SOURCE_VIDEO_DVD:
1684   2          case _SOURCE_VIDEO_SCART:
1685   2              DispIcon(1+(4*0), 1, _4BIT_ICON_COLOR_ADDR+(0*6));
1686   2              DispIcon(1+(4*1), 1, _4BIT_ICON_COLOR_ADDR+(2*6));
1687   2              DispIcon(1+(4*2), 1, _4BIT_ICON_COLOR_ADDR+(3*6));
1688   2              DispIcon(1+(4*3), 1, _4BIT_ICON_COLOR_ADDR+(4*6));
1689   2              DispIcon(1+(4*4), 1, _4BIT_ICON_COLOR_ADDR+(5*6));
1690   2      
1691   2              break;
1692   2      #endif // end #if(_TMDS_SUPPORT || _VIDEO_AV_SUPPORT || _VIDEO_SV_SUPPORT || _VIDEO_YUV_SUPPORT || _HDMI_S
             -UPPORT || _VIDEO_SCART_SUPPORT)                                    
1693   2      
1694   2      #if(_VIDEO_TV_SUPPORT)
1695   2          case _SOURCE_VIDEO_TV:
1696   2              for(uctemp = 0; uctemp < 6; uctemp++)
1697   2              {
1698   3                  DispIcon(1+(4*uctemp), 1, _4BIT_ICON_COLOR_ADDR+(uctemp*6));
1699   3              } 
1700   2              break;
1701   2      #endif  // end #if(_VIDEO_TV_SUPPORT)
1702   2          }
1703   1      }     
1704          
1705          
1706          //----------------------------------------------------------------------------------------------------
1707          void CShowSelectMainItemWindow(BYTE ucItem)
1708          {
1709   1          COsdFxDrawWindow(XSTART(16+(ucItem*48)), YSTART(12), XEND(64+(ucItem*48)), YEND(58), tOSD_SELECT_MAIN_
             -WINDOW_STYLE);
1710   1      }
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 29  

1711          
1712          //----------------------------------------------------------------------------------------------------
1713          void CShowSubItemWindow(BYTE ucItem)
1714          {
1715   1          OSDClear(4, 8, 1, COL_WIDTH-1, 0x40, BYTE_COLOR);            // Clear item color
1716   1          OSDClear((4+ucItem), 1, 1, COL_WIDTH-1, 0x10, BYTE_COLOR);   // Set current sub item character color t
             -o white
1717   1          COsdFxDrawWindow(XSTART(18), YSTART(81+(ucItem*23)), XEND(206), YEND(81+24+(ucItem*23)), tOSD_SELECT_S
             -UB_WINDOW_STYLE);
1718   1      }
1719          
1720          //----------------------------------------------------------------------------------------------------
1721          // Set window to select or move state
1722          void CSetItemWindowState(BYTE ucWinNumber, BYTE ucItemState)
1723          {
1724   1          pData[0]    = 0x81;
1725   1          pData[1]    = (BYTE)(ucWinNumber * 4+3);
1726   1          pData[2]    = SHADOW_BORDER_EN(1) | WINDOW_TYPE(ucItemState) | WINDOW_ENABLE(1);
1727   1          CScalerWrite(_OSD_ADDR_MSB_90, 3, pData, _AUTOINC);
1728   1      }
1729          
1730          //----------------------------------------------------------------------------------------------------
1731          void CExitToMainItem(BYTE ucMainItem)
1732          {
1733   1          OSDClear(4, 8, 1, COL_WIDTH-1, 0x40, BYTE_COLOR);  // Clear item color
1734   1          COsdFxCloseWindow(_SELECT_SUB_WINDOW);    // Disable sub item window
1735   1          ShowMode();
1736   1          ucOsdState = ucMainItem;
1737   1      
1738   1          CSetItemWindowState(_SELECT_MAIN_WINDOW, _MOVE_STATE); // Set main item window to move state
1739   1      }
1740          
1741          //----------------------------------------------------------------------------------------------------
1742          void CGotoNextSubItem(BYTE ucItem)
1743          {
1744   1          CShowSubItemWindow(ucItem);
1745   1          CLR_KEYREPEATENABLE();
1746   1      }
1747          
1748          //----------------------------------------------------------------------------------------------------
1749          void CClearSubItem(void)
1750          {   // Clear item character
1751   1          OSDClear(4, 8, 1, COL_WIDTH - 2, 0x00, BYTE_DISPLAY);
1752   1          OSDClear(4, 8, 1, COL_WIDTH - 2, 0x8C, BYTE_ATTRIB);
1753   1      }
1754          
1755          //----------------------------------------------------------------------------------------------------
1756          void CClearMsg(BYTE ucMode)
1757          {
1758   1          // Set Character width to 12 
1759   1          OSDLine(_MESSAGE_V_POSITION, 1, COL_WIDTH - 1, 0x8c, BYTE_ATTRIB);
1760   1          OSDClear(_MESSAGE_V_POSITION, 1, 1, COL_WIDTH - 2, 0x00, BYTE_DISPLAY);
1761   1          CLR_KEYREPEATENABLE();
1762   1          
1763   1          switch(ucMode)
1764   1          {
1765   2              case _CLEAR_AND_SELECT_SUB_ITEM:
1766   2                  CSetItemWindowState(_SELECT_SUB_WINDOW, _SELECT_STATE);
1767   2                  break;
1768   2      
1769   2              case _CLEAR_AND_EXIT_SUB_ITEM:
1770   2                  CSetItemWindowState(_SELECT_SUB_WINDOW, _MOVE_STATE);
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 30  

1771   2                  ShowMode();
1772   2                  break;
1773   2      
1774   2              case _CLEAR_MSG_ONLY:
1775   2                  break;
1776   2          }
1777   1      }
1778          
1779          //----------------------------------------------------------------------------------------------------
1780          void CDrawColorPage(void)
1781          {                     
1782   1          BYTE uctemp = 4;
1783   1              
1784   1      
1785   1          CLeftAlignTextout((BYTE *)sBright[GET_LANGUAGE], 1, uctemp++);          // "Brightness"
1786   1          CLeftAlignTextout((BYTE *)sContrast[GET_LANGUAGE], 1, uctemp++);        // "Contrast"
1787   1      
1788   1          uctemp = uctemp;
1789   1      
1790   1          switch(_GET_INPUT_SOURCE())
1791   1          {
1792   2      #if(_VGA_SUPPORT || _TMDS_SUPPORT || _YPBPR_SUPPORT || _HDMI_SUPPORT)
1793   2          case _SOURCE_VGA:
1794   2          case _SOURCE_DVI:
1795   2          case _SOURCE_HDMI:
1796   2          case _SOURCE_YPBPR:
1797   2          #if(_COLOR_TEMP)
                      if (_SOURCE_YPBPR != _GET_INPUT_SOURCE())
                      {
                          CLeftAlignTextout((BYTE *)sColorTemp[GET_LANGUAGE], 1, uctemp++);   // "Color Temp."
                          uctemp = uctemp;
                      }
                      else
                          uctemp = uctemp;
                  #else
1806   2              uctemp = uctemp;
1807   2          #endif
1808   2              break;
1809   2      #endif
1810   2      
1811   2      #if(_VIDEO_SUPPORT)                                    
1812   2          case _SOURCE_VIDEO_AV:
1813   2          case _SOURCE_VIDEO_SV:
1814   2        //  case _SOURCE_VIDEO_YUV:
1815   2          case _SOURCE_VIDEO_TV:
1816   2          case _SOURCE_VIDEO_SCART:
1817   2          case _SOURCE_VIDEO_DVD:
1818   2              CLeftAlignTextout((BYTE *)sSaturation[GET_LANGUAGE], 1, uctemp++);  // "Saturation"
1819   2              if(CHECK60HZ())
1820   2              CLeftAlignTextout((BYTE *)sHue[GET_LANGUAGE], 1, uctemp++);         // "Hue"
1821   2                  uctemp = uctemp;
1822   2              break;
1823   2      #endif
1824   2          }
1825   1      
1826   1          CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, uctemp);    // "Exit"
1827   1      
1828   1      }
1829          
1830          //----------------------------------------------------------------------------------------------------
1831          void CDrawOSDFuncPage(void)
1832          {
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 31  

1833   1          BYTE uctemp = 4;
1834   1      
1835   1          CLeftAlignTextout((BYTE *)sLanguage[GET_LANGUAGE], 1, uctemp++);       // "Language"
1836   1      
1837   1      #if(_OSD_POSITION_ADJ_CTRL)
                  CLeftAlignTextout((BYTE *)sOSDHPosition[GET_LANGUAGE], 1, uctemp++);       // "OSD H Position"
                  CLeftAlignTextout((BYTE *)sOSDVPosition[GET_LANGUAGE], 1, uctemp++);       // "OSD V Position"
              #else
1841   1      #endif
1842   1          
1843   1      #if(_OSD_TIMEOUT_ADJ_CTRL)
                  CLeftAlignTextout((BYTE *)sOSDTimeOut[GET_LANGUAGE], 1, uctemp++);     // "OSD Timeout"
              #endif
1846   1      
1847   1      #if(_ALPHA_BLENDING_ADJ == _ON)
                  CLeftAlignTextout((BYTE *)sOSDTranslucent[GET_LANGUAGE], 1, uctemp++); // "OSD Translucent"
              #endif
1850   1      
1851   1      #if(_OSD_DISPLAY_SIZE_ADJ == _ON)
1852   1      if(Panel.DHWidth>1024||Panel.DVHeight>768)
1853   1              {
1854   2               CLeftAlignTextout((BYTE *)sOSDSize[GET_LANGUAGE], 1, uctemp++);        // "OSD Size"
1855   2      
1856   2           }
1857   1      #endif
1858   1         #if(_DISPLAY_SIZE_ADJ)
1859   1              if(Panel.DHWidth > (Panel.DVHeight * 4/3)) 
1860   1              //if(!((_GET_INPUT_SOURCE()==_SOURCE_VGA)||(_GET_INPUT_SOURCE()==_SOURCE_DVI)))
1861   1              {
1862   2                CLeftAlignTextout((BYTE *)sDispMode[GET_LANGUAGE], 1, uctemp++);        // "OSD Size"
1863   2              }
1864   1      #endif
1865   1      
1866   1          CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, uctemp++);           // "Exit"
1867   1      }
1868          
1869          //----------------------------------------------------------------------------------------------------
1870          void CDrawSoundPage(void)
1871          {
1872   1          CLeftAlignTextout((BYTE *)sVolume[GET_LANGUAGE], 1, 4);          // "Volume"
1873   1          CLeftAlignTextout((BYTE *)sMute[GET_LANGUAGE], 1, 5);            // "Mute"
1874   1      
1875   1      #if(_SOUND_PROCESSOR == _ENABLE)
                  CLeftAlignTextout((BYTE *)sBalance[GET_LANGUAGE], 1, 6);         // "Balance"
                  CLeftAlignTextout((BYTE *)sBass[GET_LANGUAGE], 1, 7);            // "Bass"
                  CLeftAlignTextout((BYTE *)sTreble[GET_LANGUAGE], 1, 8);          // "Treble"
                  CLeftAlignTextout((BYTE *)sSRS[GET_LANGUAGE], 1, 9);             // "SRS"
                  CLeftAlignTextout((BYTE *)sBBE[GET_LANGUAGE], 1, 10);            // "BBE"
                  CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, 11);           // "Exit"
              #else
1883   1          CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, 6);            // "Exit"
1884   1      #endif
1885   1      }
1886          //----------------------------------------------------------------------------------------------------
1887          
1888          #if(_VGA_COLOR_SUPPORT)
              void CDrawVividColorPage(void)
              {         
                  CClearVColorItem();                                             
                  CLeftAlignTextout((BYTE *)sText, 1, 1);                // "Text"
                  CLeftAlignTextout((BYTE *)sMovie, 1, 2);               // "Movie"
                  CLeftAlignTextout((BYTE *)sGraphic, 1, 3);             // "Graphic"
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 32  

                  CLeftAlignTextout((BYTE *)sGame, 1, 4);                // "Game"
                  CLeftAlignTextout((BYTE *)sNormal, 1, 5);              // "Normal"
                  CLeftAlignTextout((BYTE *)sUser, 1, 6);                // "User"
                  CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, 7);  // "Exit"
                  
              
              }
              //----------------------------------------------------------------------------------------------------
              void CDrawVividColorSubPage(void)
              {
                  CClearVColorItem();
                  CLeftAlignTextout((BYTE *)sVividColor, 3, 1);          // "Vivid Color"
                  CLeftAlignTextout((BYTE *)sDCC, 4, 3);                 // "DCC"
                  CLeftAlignTextout((BYTE *)sICM, 4, 4);                 // "ICM"
                  CLeftAlignTextout((BYTE *)sColor, 4, 5);               // "Color"
                  CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 4, 6);  // "Exit" 
              }
              
              //----------------------------------------------------------------------------------------------------
              void CDrawDCCPage(void)
              {
                  CClearVColorItem();
                  CLeftAlignTextout((BYTE *)sText, 3, 1);                // "Text"
                  CLeftAlignTextout((BYTE *)sMovie, 3, 2);               // "Movie"
                  CLeftAlignTextout((BYTE *)sGraphic, 3, 3);             // "Graphic"
                  CLeftAlignTextout((BYTE *)sGame, 3, 4);                // "Game"
                  CLeftAlignTextout((BYTE *)sDCCNormal, 3, 5);           // "DCC Normal"
              }
              
              //----------------------------------------------------------------------------------------------------
              void CDrawICMPage(void)
              {
                  CClearVColorItem(); 
                  CLeftAlignTextout((BYTE *)sRed, 1, 1);                  // "Red"
                  CLeftAlignTextout((BYTE *)sGreen, 1, 2);                // "Green"
                  CLeftAlignTextout((BYTE *)sBlue_ENG, 1, 3);             // "Blue"
                  CLeftAlignTextout((BYTE *)sYellow, 1, 4);               // "Yellow"
                  CLeftAlignTextout((BYTE *)sCyan, 1, 5);                 // "Cyan"
                  CLeftAlignTextout((BYTE *)sMagenta, 1, 6);              // "Magenta"                                
                  CLeftAlignTextout((BYTE *)sICM, 1, 7);                  // "ICM"
                  CenterTextout((BYTE *)sOn_Off[GET_MZ_ICM_ON_OFF_TYPE()][GET_LANGUAGE], 8, 7);
                  CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, 8);   // "Exit"  
              }
              
              //----------------------------------------------------------------------------------------------------
              void CDrawVividSubColorPage(void)
              {
                  CClearVColorItem();
                  CLeftAlignTextout((BYTE *)sBright[GET_LANGUAGE], 1, 1);    // "Bright"
                  Gotoxy(13, 1, BYTE_DISPLAY);         
                  CShowNumber(stOsdUserData.MZBright, 0);
              
                  CLeftAlignTextout((BYTE *)sContrast[GET_LANGUAGE], 1, 3);  // "Contrast"
                  Gotoxy(12, 3, BYTE_DISPLAY);         
                  CShowNumber(stOsdUserData.MZContrast, 0);
              
                  CLeftAlignTextout((BYTE *)sPeaking, 1, 5);                 // "Peaking"
                  Gotoxy(12, 5, BYTE_DISPLAY);         
                  CShowNumber(stOsdUserData.MZPeaking, 0);
              
                  CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, 7);      // "Exit"
              }
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 33  

              
              //----------------------------------------------------------------------------------------------------
              void CDrawICMColorAdjPage(void)
              {
                  CClearVColorItem();
                  CLeftAlignTextout((BYTE *)sHue[GET_LANGUAGE], 1, 2);         // "Hue"
                  CLeftAlignTextout((BYTE *)sSaturation[GET_LANGUAGE], 1, 4);  // "Saturation"
                  CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, 6);        // "Exit"
              
              }
              #endif
1968          
1969          //----------------------------------------------------------------------------------------------------
1970          void CDrawOtherFuncPage(void)
1971          {
1972   1          BYTE uctemp = 5;
1973   1          CLeftAlignTextout((BYTE *)sReset[GET_LANGUAGE], 1, 4);           // "Reset"
1974   1      /* for close blue adjust by chenlinfu 2007/09/28
1975   1      #if(_BLUE_BACKGROUND_FUNC == _ENABLE)
1976   1          CLeftAlignTextout((BYTE *)sBlue[GET_LANGUAGE], 1, 5);            // "Blue"
1977   1          uctemp++;
1978   1      #endif
1979   1      */
1980   1      #if(_AUTO_POWER_DOWN)
1981   1          CLeftAlignTextout((BYTE *)sAutoPowerDown[GET_LANGUAGE], 1, uctemp);   // "Auto power down"
1982   1          uctemp++;
1983   1      #endif
1984   1                
1985   1      #if(_IMAGE_COLOR_MODE)
1986   1          CLeftAlignTextout((BYTE *)sColorMode[GET_LANGUAGE], 1, uctemp);  // "Color mode"
1987   1          uctemp++;
1988   1      #endif
1989   1                 
1990   1      #if(_SHARPNESS_ADJ)
                  CLeftAlignTextout((BYTE *)sSharp[GET_LANGUAGE], 1, uctemp);      // "Sharp"
                  uctemp++;
              #endif      
1994   1      
1995   1          CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, uctemp);       // "Exit"
1996   1      }   
1997          
1998          //----------------------------------------------------------------------------------------------------
1999          void CDrawExitPage(void)
2000          {
2001   1          CLeftAlignTextout((BYTE *)sExit[GET_LANGUAGE], 1, 4);            // "Exit"
2002   1      }
2003          
2004          //----------------------------------------------------------------------------------------------------
2005          //   Color Sub item
2006          void MColorSubItemProc(void)
2007          {
2008   1          switch(ucKeyMessage)
2009   1          {
2010   2              // Select item
2011   2      #if(_USE_UD_LR_KEY_MSG)
2012   2              case VK_F_LEFT:
2013   2              case VK_F_RIGHT:
2014   2      #endif
2015   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
2016   2              case VK_RIGHT:        
2017   2              case VK_LEFT:     
2018   2      #else
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 34  

                      case VK_MENU:    
              #endif
2021   2              case VK_IR_OK:    
2022   2                              MColorSubItemMenu();               break;
2023   2      
2024   2              // Move item
2025   2      #if(_USE_UD_LR_KEY_MSG)
2026   2              case VK_F_UP:
2027   2      #endif
2028   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_RIGHT:        
              #endif
2031   2                              MColorSubItemLR(1);                break;
2032   2      
2033   2              // Move item
2034   2      #if(_USE_UD_LR_KEY_MSG)
2035   2              case VK_F_DOWN:
2036   2      #endif
2037   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_LEFT:      
              #endif
2040   2                              MColorSubItemLR(0);                break;
2041   2      
2042   2              // Exit item
2043   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
2044   2              case VK_ENTER:      
2045   2      #endif
2046   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
2047   2              case VK_MENU:    
2048   2      #endif
2049   2              case VK_AUTO:
2050   2              case VK_IR_EXIT:
2051   2               CExitToMainItem(MENU_MAIN_COLOR);  break;
2052   2              // Other key
2053   2              default:             COthterKeyAction();                break;
2054   2          }
2055   1      }
2056          
2057          //----------------------------------------------------------------------------------------------------
2058          void MColorSubItemMenu(void)
2059          {      
2060   1          CClearMsg(_CLEAR_AND_SELECT_SUB_ITEM);
2061   1      
2062   1          switch(ucOsdState)
2063   1          {
2064   2              case MENU_ITEM_BRIGHT:  
2065   2                  SLIDER1(BRIGHTNESS_GUAGE);
2066   2                  ucOsdState = MENU_SUB_BRIGH_ADJ;     
2067   2                  _SET_IMAGE_COLOR_MODE(3); // Mode user  //0228 guo
2068   2                  CEepromSaveOsdUserData();
2069   2                  break;
2070   2      
2071   2              case MENU_ITEM_CONTRAST:       
2072   2                  SLIDER1(CONTRAST_GUAGE);
2073   2                  ucOsdState = MENU_SUB_CONTRAST_ADJ;   
2074   2                  _SET_IMAGE_COLOR_MODE(3); // Mode user //0228 guo
2075   2                  CEepromSaveOsdUserData();
2076   2                  break;
2077   2      
2078   2      #if(_VGA_SUPPORT || _TMDS_SUPPORT || _YPBPR_SUPPORT)
2079   2         #if(_COLOR_TEMP)
                      case MENU_ITEM_COLOR_TEMP:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 35  

                          CClearSubItem();
                          CDrawColorTempSubItem();
                          {
                              BYTE ucTemp = GET_COLOR_TEMP_TYPE();
              
                              switch(ucTemp)
                              {
                                  case 0:
                                      ucOsdState = MENU_SUB_CT_9300;        
                                      break;
              
                                  case 1:
                                      ucOsdState = MENU_SUB_CT_6500;        
                                      break;
              
                                  case 2:
                                      ucOsdState = MENU_SUB_CT_USER;        
                                      break;
              
                                  default:
                                      ucOsdState = MENU_SUB_CT_USER; 
                                      SET_COLOR_TEMP_TYPE(_CT_USER);
                                      break;
                              }
              
                              CShowSubItemWindow(ucTemp);
                          }
                          break;
                 #endif
2110   2      #endif
2111   2      
2112   2      #if(_VIDEO_SUPPORT)
2113   2              case MENU_AV_SATURATION:
2114   2                  SLIDER1(SATURATION_GUAGE);
2115   2                  ucOsdState = MENU_AV_SATURATION_ADJ;
2116   2                  _SET_IMAGE_COLOR_MODE(3); // Mode user //0228 guo
2117   2                  CEepromSaveOsdUserData();
2118   2                  break;
2119   2      
2120   2              case MENU_AV_HUE:
2121   2                  SLIDER1(HUE_GUAGE);
2122   2                  ucOsdState = MENU_AV_HUE_ADJ;
2123   2                  break;
2124   2      #endif
2125   2      
2126   2              case MENU_SUB_COLOR_CLOSE:
2127   2                  CExitToMainItem(MENU_MAIN_COLOR);
2128   2                  break;
2129   2          }
2130   1      }
2131          
2132          //----------------------------------------------------------------------------------------------------
2133          void MColorSubItemLR(BYTE LR)
2134          {
2135   1          BYTE ucTemp = 0;
2136   1      
2137   1          if(LR)
2138   1          {
2139   2              switch(ucOsdState)
2140   2              {
2141   3                  case MENU_ITEM_BRIGHT:         ucOsdState = MENU_ITEM_CONTRAST;     break;
2142   3                  case MENU_ITEM_CONTRAST:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 36  

2143   3                  
2144   3      #if(_VIDEO_SUPPORT)
2145   3         #if(_COLOR_TEMP)
                              if (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2)  // Source video
                                  ucOsdState = MENU_AV_SATURATION;
                              else
                                  ucOsdState = (_SOURCE_YPBPR == _GET_INPUT_SOURCE()) ? MENU_SUB_COLOR_CLOSE : MENU_ITEM
             -_COLOR_TEMP;
              //                ucOsdState = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? MENU_AV_SATURATION : MENU_
             -ITEM_COLOR_TEMP;
                 #else
2152   3                      ucOsdState = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? MENU_AV_SATURATION : MENU_SU
             -B_COLOR_CLOSE;
2153   3         #endif
2154   3      #else
                 #if(_COLOR_TEMP)
                              ucOsdState = MENU_ITEM_COLOR_TEMP;
                 #else
                              ucOsdState = MENU_SUB_COLOR_CLOSE;
                 #endif
              #endif           
2161   3                      break;
2162   3      
2163   3      #if(_VIDEO_SUPPORT)
2164   3                  case MENU_AV_SATURATION:       
2165   3                                 
2166   3                         if(CHECK60HZ())
2167   3                                      ucOsdState = MENU_AV_HUE;    
2168   3                          else
2169   3                                    ucOsdState = MENU_SUB_COLOR_CLOSE; 
2170   3                                break;
2171   3                  case MENU_AV_HUE:              ucOsdState = MENU_SUB_COLOR_CLOSE;   break;
2172   3      #endif
2173   3      
2174   3                  case MENU_ITEM_COLOR_TEMP:     ucOsdState = MENU_SUB_COLOR_CLOSE;   break;
2175   3                  case MENU_SUB_COLOR_CLOSE:     ucOsdState = MENU_ITEM_BRIGHT;       break;
2176   3              }
2177   2          }
2178   1          else
2179   1          {
2180   2              switch(ucOsdState)
2181   2              {
2182   3                  case MENU_ITEM_BRIGHT:         ucOsdState = MENU_SUB_COLOR_CLOSE;   break;
2183   3                  case MENU_ITEM_CONTRAST:       ucOsdState = MENU_ITEM_BRIGHT;       break;
2184   3                  case MENU_ITEM_COLOR_TEMP:     ucOsdState = MENU_ITEM_CONTRAST;     break;
2185   3      
2186   3      #if(_VIDEO_SUPPORT)
2187   3                  case MENU_AV_SATURATION:       ucOsdState = MENU_ITEM_CONTRAST;     break;
2188   3                  case MENU_AV_HUE:              ucOsdState = MENU_AV_SATURATION;     break;
2189   3                  case MENU_SUB_COLOR_CLOSE:
2190   3         #if(_COLOR_TEMP)
                              if (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2)  // Source video
                                      {
                      if((CHECK60HZ()))
                              ucOsdState = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? MENU_AV_HUE : MENU_ITEM_COLO
             -R_TEMP;
                      else
                              ucOsdState = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? MENU_AV_SATURATION : MENU_IT
             -EM_COLOR_TEMP;
                                      }
                                              
                                  //ucOsdState = MENU_AV_HUE;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 37  

                              else
                                  ucOsdState = (_SOURCE_YPBPR == _GET_INPUT_SOURCE()) ? MENU_ITEM_CONTRAST : MENU_ITEM_C
             -OLOR_TEMP;
              
                            //  ucOsdState = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? MENU_AV_HUE : MENU_ITEM_CO
             -LOR_TEMP;
                 #else
2205   3              if(CHECK60HZ())
2206   3                      ucOsdState = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? MENU_AV_HUE : MENU_AV_SATURA
             -TION;
2207   3              else
2208   3                      ucOsdState = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? MENU_AV_SATURATION : MENU_IT
             -EM_CONTRAST;
2209   3         #endif
2210   3                      break;
2211   3      #else
                 #if(_COLOR_TEMP)
                          case MENU_SUB_COLOR_CLOSE:     ucOsdState = MENU_ITEM_COLOR_TEMP;   break;
                 #else
                          case MENU_SUB_COLOR_CLOSE:     ucOsdState = MENU_ITEM_CONTRAST;     break;
                 #endif
              #endif
2218   3              }
2219   2          }
2220   1          
2221   1          switch(ucOsdState)
2222   1          {      
2223   2              case MENU_ITEM_BRIGHT:
2224   2                  ucTemp = 0;      
2225   2                  break;
2226   2      
2227   2              case MENU_ITEM_CONTRAST:
2228   2                  ucTemp = 1;      
2229   2                  break;
2230   2      
2231   2      #if(_VIDEO_SUPPORT)
2232   2              case MENU_AV_SATURATION:
2233   2                  ucTemp = 2;
2234   2                  break;
2235   2      
2236   2              if(CHECK60HZ())
2237   2                      {
2238   3              case MENU_AV_HUE:
2239   3                  ucTemp = 3;
2240   3                  break;
2241   3                      }
2242   2      #endif
2243   2      
2244   2      #if(_COLOR_TEMP)
                      case MENU_ITEM_COLOR_TEMP:
                          ucTemp = 2;      
                          break;
              #endif
2249   2      
2250   2              case MENU_SUB_COLOR_CLOSE:
2251   2      #if(_VIDEO_SUPPORT)
2252   2          #if(_COLOR_TEMP)
                          if (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2)  // Source video
                              ucTemp = 4;
                          else
                              ucTemp = (_SOURCE_YPBPR == _GET_INPUT_SOURCE()) ? 2 : 3;
              //            ucTemp = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? 4 : 3; 
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 38  

                  #else
2259   2              if(CHECK60HZ())
2260   2                  ucTemp = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? 4 : 2; 
2261   2                      else
2262   2                  ucTemp = (CGetInputSourceNum(_GET_INPUT_SOURCE()) == 2) ? 3 : 2; 
2263   2          #endif
2264   2      #else
                  #if(_COLOR_TEMP)
                          ucTemp = 3;      
                  #else
                          ucTemp = 2;      
                  #endif
              #endif     
2271   2                  break;
2272   2          }   
2273   1          
2274   1          CGotoNextSubItem(ucTemp);
2275   1      }
2276          
2277          
2278          //----------------------------------------------------------------------------------------------------
2279          //   OSD Sub item
2280          void MOSDSubItemProc(void)
2281          {
2282   1          switch(ucKeyMessage)
2283   1          {
2284   2              // Select item
2285   2      #if(_USE_UD_LR_KEY_MSG)
2286   2              case VK_F_LEFT:
2287   2              case VK_F_RIGHT:
2288   2      #endif
2289   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
2290   2              case VK_RIGHT:        
2291   2              case VK_LEFT:     
2292   2      #else
                      case VK_MENU:     
              #endif
2295   2              case VK_IR_OK:     
2296   2                              MOSDSubItemMenu();                    break;
2297   2      
2298   2              // Move item
2299   2      #if(_USE_UD_LR_KEY_MSG)
2300   2              case VK_F_UP:
2301   2      #endif
2302   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_RIGHT:        
              #endif
2305   2                              MOSDSubItemLR(1);                     break;
2306   2      
2307   2              // Move item
2308   2      #if(_USE_UD_LR_KEY_MSG)
2309   2              case VK_F_DOWN:
2310   2      #endif
2311   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_LEFT:       
              #endif
2314   2                              MOSDSubItemLR(0);                     break;
2315   2      
2316   2              // Exit item
2317   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
2318   2              case VK_ENTER:       
2319   2      #endif
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 39  

2320   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
2321   2              case VK_MENU:     
2322   2      #endif
2323   2              case VK_AUTO:
2324   2              case VK_IR_EXIT:
2325   2              CExitToMainItem(MENU_MAIN_OSD_FUNC);  break;
2326   2              // Other key
2327   2              default:             COthterKeyAction();                   break;
2328   2          }
2329   1      }
2330          
2331          //----------------------------------------------------------------------------------------------------
2332          void MOSDSubItemMenu(void)
2333          {
2334   1          CClearMsg(_CLEAR_AND_SELECT_SUB_ITEM);
2335   1      
2336   1          switch(ucOsdState)
2337   1          {
2338   2              case MENU_SUB_LANGUAGE:
2339   2                  CenterTextout((BYTE *)sLangName[GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
2340   2                  ucOsdState = MENU_SUB_OSDLANGUAGE_ADJ;     
2341   2                  break;
2342   2      
2343   2      #if(_OSD_POSITION_ADJ_CTRL)
                      case MENU_SUB_H_POSITION:       
                          SLIDER1(stOsdUserData.OsdHPos);
                          ucOsdState = MENU_SUB_OSDH_POSITION_ADJ;   
                          break;
              
                      case MENU_SUB_V_POSITION:     
                          SLIDER1(stOsdUserData.OsdVPos);
                          ucOsdState = MENU_SUB_OSDV_POSITION_ADJ;   
                          break;
              #endif
2354   2      
2355   2      #if(_OSD_TIMEOUT_ADJ_CTRL)
                      case MENU_SUB_OSD_TIMEOUT:  
                          if (stOsdUserData.OsdTimeout < 5)
                          {
                              CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
                          }
                          else
                          {
                              Gotoxy(14, _MESSAGE_V_POSITION, BYTE_DISPLAY);
                              CShowNumber(stOsdUserData.OsdTimeout, 0);
                          }
                          ucOsdState = MENU_SUB_OSD_TIMEOUT_ADJ;   
                          break;
              #endif
2369   2      
2370   2      #if(_ALPHA_BLENDING_ADJ)
                      case MENU_SUB_OSD_TRANSLUCENT:
                          if (0 == _GET_OSD_TRANSLUCENT())
                          {
                              CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
                          }
                          else
                          {
                              Gotoxy(14, _MESSAGE_V_POSITION, BYTE_DISPLAY);
                              CShowNumber(_GET_OSD_TRANSLUCENT(), 0);
                          }
                          ucOsdState = MENU_SUB_OSD_TRANS_ADJ;   
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 40  

                          break;
              #endif
2384   2      
2385   2      #if(_OSD_DISPLAY_SIZE_ADJ)
2386   2      if(Panel.DHWidth>1024||Panel.DVHeight>768)
2387   2              {
2388   3              case MENU_SUB_OSD_SIZE:
2389   3                  CenterTextout((BYTE *)sOn_Off[_GET_OSD_SIZE()][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
2390   3                  ucOsdState = MENU_SUB_OSD_SIZE_ADJ;   
2391   3                  break;
2392   3              }
2393   2      #endif
2394   2      
2395   2            #if(_DISPLAY_SIZE_ADJ)
2396   2                 if(Panel.DHWidth > (Panel.DVHeight * 4/3)) 
2397   2                      {
2398   3                   case MENU_SUB_DISMODE:
2399   3                         CenterTextout((BYTE *)sDisp_mode[_GET_DISPLAY_MODE()], 14, _MESSAGE_V_POSITION);
2400   3                         ucOsdState = MENU_SUB_DISPMODE_ADJ;     
2401   3                  break;
2402   3                      }
2403   2      #endif
2404   2      
2405   2              case MENU_SUB_OSD_CLOSE:
2406   2                  CExitToMainItem(MENU_MAIN_OSD_FUNC);
2407   2                  break;
2408   2          }
2409   1      }
2410          
2411          //----------------------------------------------------------------------------------------------------
2412          bit bOSDItemSupport(BYTE ucOSDItem)
2413          {
2414   1          switch(ucOSDItem)
2415   1          {
2416   2              case MENU_SUB_LANGUAGE:
2417   2              case MENU_SUB_OSD_CLOSE:
2418   2                  return 1;
2419   2            #if(_DISPLAY_SIZE_ADJ)
2420   2                      case MENU_SUB_DISMODE:
2421   2                 if(Panel.DHWidth > (Panel.DVHeight * 4/3)) 
2422   2                  return 1;
2423   2                  else
2424   2                  return 0;
2425   2           #endif
2426   2      
2427   2      #if(_OSD_POSITION_ADJ_CTRL)
                      case MENU_SUB_H_POSITION:
                      case MENU_SUB_V_POSITION:
                          return 1;
              #endif
2432   2      
2433   2      #if(_OSD_TIMEOUT_ADJ_CTRL)
                      case MENU_SUB_OSD_TIMEOUT:
                          return 1;
              #endif
2437   2      
2438   2      #if(_ALPHA_BLENDING_ADJ)
                      case MENU_SUB_OSD_TRANSLUCENT:
                          return 1;
              #endif
2442   2      
2443   2      #if(_OSD_DISPLAY_SIZE_ADJ)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 41  

2444   2              case MENU_SUB_OSD_SIZE:
2445   2      if(Panel.DHWidth>1024||Panel.DVHeight>768)
2446   2                  return 1;
2447   2               else
2448   2                  return 0;
2449   2      #endif
2450   2          } 
2451   1          
2452   1          return 0;
2453   1      }
2454          
2455          //----------------------------------------------------------------------------------------------------
2456          void MOSDSubItemLR(BYTE LR)
2457          {
2458   1          BYTE ucTemp  = 0;
2459   1          BYTE ucItem  = 0;
2460   1          
2461   1          // Search next item
2462   1          while(1)
2463   1          {
2464   2              ucOsdState = ValueInRangeChange(MENU_SUB_LANGUAGE, MENU_SUB_OSD_CLOSE, ucOsdState, LR, 1);
2465   2      
2466   2              if (bOSDItemSupport(ucOsdState))
2467   2                  break; 
2468   2          }
2469   1      
2470   1          // Search item position
2471   1          ucTemp = MENU_SUB_LANGUAGE;
2472   1          while(1)
2473   1          {
2474   2              if (ucOsdState == ucTemp)
2475   2                 break;
2476   2      
2477   2              ucTemp = ValueInRangeChange(MENU_SUB_LANGUAGE, MENU_SUB_OSD_CLOSE,ucTemp, 1, 1);
2478   2      
2479   2              if (bOSDItemSupport(ucTemp))
2480   2                 ucItem++;
2481   2          }
2482   1      
2483   1          CGotoNextSubItem(ucItem);
2484   1      }
2485          
2486          
2487          //----------------------------------------------------------------------------------------------------
2488          #if(_OSD_POSITION_ADJ_CTRL)
              // OSD H position
              void MOSDHPositionAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MOSDHPositionAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 42  

              #endif
                      case VK_AUTO:
                      case VK_IR_EXIT:
                      case VK_MENU:        MOSDHPositionAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MOSDHPositionAdjLR(1);        break;
                  
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MOSDHPositionAdjLR(0);        break;
                             
                      // Other key
                      default:             COthterKeyAction();      break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDHPositionAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_H_POSITION;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDHPositionAdjLR(BYTE LR)
              {
                  SET_KEYREPEATENABLE();
                  stOsdUserData.OsdHPos = ValueInRangeChange(0, 100, stOsdUserData.OsdHPos, LR, 0);
                  SLIDER1(stOsdUserData.OsdHPos);
                  SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
                   if (_GET_OSD_SIZE()) 
                      OSDPosition(_OSD_DOUBLE_WIDTH(_MAIN_WINDOW_WIDTH), _OSD_DOUBLE_HEIGHT(_MAIN_WINDOW_HEIGHT), stOsdU
             -serData.OsdHPos+(_MAINMENU_DOUBLE_H_OFFSET), stOsdUserData.OsdVPos+(_MAINMENU_DOUBLE_V_OFFSET), 0x03);
                    else
                      OSDPosition(_MAIN_WINDOW_WIDTH, _MAIN_WINDOW_HEIGHT, stOsdUserData.OsdHPos+(_MAINMENU_H_OFFSET), s
             -tOsdUserData.OsdVPos+(_MAINMENU_V_OFFSET), 0x03);
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              //----------------------------------------------------------------------------------------------------
              
              // OSD V position
              void MOSDVPositionAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MOSDVPositionAdjMenu();
                          COsdProc();
                          break;
              #endif
              
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 43  

                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_AUTO:
                      case VK_IR_EXIT:
                      case VK_MENU:        MOSDVPositionAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MOSDVPositionAdjLR(1);        break;
                  
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MOSDVPositionAdjLR(0);        break;
                              
                      // Other key
                      default:             COthterKeyAction();           break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDVPositionAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_V_POSITION;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDVPositionAdjLR(BYTE LR)
              {
                  SET_KEYREPEATENABLE();
                  stOsdUserData.OsdVPos = ValueInRangeChange(0, 100, stOsdUserData.OsdVPos, LR, 0);
                  SLIDER1(stOsdUserData.OsdVPos);
                   if (_GET_OSD_SIZE()) 
                      OSDPosition(_OSD_DOUBLE_WIDTH(_MAIN_WINDOW_WIDTH), _OSD_DOUBLE_HEIGHT(_MAIN_WINDOW_HEIGHT), stOsdU
             -serData.OsdHPos+(_MAINMENU_DOUBLE_H_OFFSET), stOsdUserData.OsdVPos+(_MAINMENU_DOUBLE_V_OFFSET), 0x03);
                    else
                      OSDPosition(_MAIN_WINDOW_WIDTH, _MAIN_WINDOW_HEIGHT, stOsdUserData.OsdHPos+(_MAINMENU_H_OFFSET), s
             -tOsdUserData.OsdVPos+(_MAINMENU_V_OFFSET), 0x03);
                  SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              #endif
2614          //----------------------------------------------------------------------------------------------------
2615          
2616          #if(_OSD_TIMEOUT_ADJ_CTRL)
              // OSD timeout
              void MOSDTimeoutAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 44  

                          MOSDTimeoutAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_AUTO:
                      case VK_IR_EXIT:
                      case VK_MENU:        MOSDTimeoutAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MOSDTimeoutAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MOSDTimeoutAdjLR(0);        break;
                         
                      // Other key
                      default:             COthterKeyAction();         break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDTimeoutAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_OSD_TIMEOUT;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDTimeoutAdjLR(BYTE LR)
              {
                  SET_KEYREPEATENABLE();
                  CClearMsg(_CLEAR_MSG_ONLY);
              
                  stOsdUserData.OsdTimeout = ValueInRangeChange(4, 30, stOsdUserData.OsdTimeout, LR, 1);
              
                  if (stOsdUserData.OsdTimeout == 4)
                  {
                      CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
                  }
                  else
                  {
                      Gotoxy(14, _MESSAGE_V_POSITION, BYTE_DISPLAY);
                      CShowNumber(stOsdUserData.OsdTimeout, 0);
                  }
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              #endif
2685          //----------------------------------------------------------------------------------------------------
2686          
2687          #if(_ALPHA_BLENDING_ADJ)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 45  

              // OSD Translucent sub item
              void MOSDTranslucentAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MOSDTranslucentAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_AUTO:
                      case VK_IR_EXIT:
                      case VK_MENU:        MOSDTranslucentAdjMenu();       break;
              
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MOSDTranslucentAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MOSDTranslucentAdjLR(0);        break;
                          
                      // Other key
                      default:             COthterKeyAction();             break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDTranslucentAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_OSD_TRANSLUCENT;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
              }
              
              //----------------------------------------------------------------------------------------------------
              void MOSDTranslucentAdjLR(BYTE LR)
              {
                  BYTE ucTemp = _GET_OSD_TRANSLUCENT();
              
                  CClearMsg(_CLEAR_MSG_ONLY);
              
                  ucTemp = ValueInRangeChange(0, 7, ucTemp, LR, 1);
              
                  _SET_OSD_TRANSLUCENT(ucTemp);
                  CSetOSDTransAndSize();
              
                  if (ucTemp == 0)
                  {
                      CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 46  

                  }
                  else
                  {
                      Gotoxy(14, _MESSAGE_V_POSITION, BYTE_DISPLAY);
                      CShowNumber(ucTemp, 0);
                  }
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              #endif
2761          
2762          //----------------------------------------------------------------------------------------------------
2763          #if(_ALPHA_BLENDING_ADJ || _OSD_DISPLAY_SIZE_ADJ)
2764          void CSetOSDTransAndSize(void)
2765          {
2766   1          BYTE ucTemp      = 0;
2767   1          BYTE ucTransMode = _GET_OSD_TRANSLUCENT();
2768   1      #if(_OSD_DISPLAY_SIZE_ADJ)
2769   1          BYTE ucOSDSize   = _GET_OSD_SIZE();
2770   1      #endif
2771   1      
2772   1          switch(ucTransMode)
2773   1          {
2774   2              case 0:  // Disable osd translucent
2775   2                  pData[0] = 0x40;
2776   2                  pData[1] = 0x03;
2777   2      #if(_OSD_DISPLAY_SIZE_ADJ)
2778   2      if(Panel.DHWidth>1024||Panel.DVHeight>768)
2779   2                  pData[2] = ((ucOSDSize) ? 0x03 : 0x00) | 0xa0;
2780   2          else
2781   2                  pData[2] = 0xa0;
2782   2      #else
                          pData[2] = 0xa0;
              #endif
2785   2                  CScalerWrite(_OSD_ADDR_MSB_90,3,pData,_AUTOINC);
2786   2                  break;
2787   2      
2788   2              case 1:
2789   2              case 2:
2790   2              case 3:
2791   2              case 4:
2792   2              case 5:
2793   2              case 6:
2794   2              case 7:
2795   2                  pData[0] = 0x40;
2796   2                  pData[1] = 0x03;
2797   2      #if(_OSD_DISPLAY_SIZE_ADJ)
2798   2                  pData[2] = ((ucOSDSize) ? 0x0f : 0x0c) | 0xa0;
2799   2      #else
                          pData[2] = 0x0c | 0xa0;
              #endif
2802   2                  CScalerWrite(_OSD_ADDR_MSB_90,3,pData,_AUTOINC);
2803   2      
2804   2                  CScalerRead(_OVERLAY_CTRL_6C, 1, &ucTemp, _NON_AUTOINC);
2805   2                  ucTemp = (ucTemp & 0xe3) | (ucTransMode << 2);
2806   2                  CScalerSetByte(_OVERLAY_CTRL_6C, ucTemp);
2807   2                  break;
2808   2          }
2809   1      }
2810          #endif
2811          
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 47  

2812          #if(_OSD_DISPLAY_SIZE_ADJ)
2813          //--------- OSD Size proc ----------------------------------
2814          void MOSDSizeAdjProc(void)
2815          {
2816   1          switch(ucKeyMessage)
2817   1          {
2818   2              // Move item
2819   2      #if(_USE_UD_LR_KEY_MSG)
2820   2              case VK_F_UP:
2821   2              case VK_F_DOWN:
2822   2                  MOSDSizeAdjMenu();
2823   2                  COsdProc();
2824   2                  break;
2825   2      #endif
2826   2      
2827   2              // Exit item
2828   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
2829   2              case VK_ENTER: 
2830   2      #endif
2831   2              case VK_AUTO:
2832   2              case VK_IR_EXIT:
2833   2              case VK_MENU:        MOSDSizeAdjMenu();       break;
2834   2      
2835   2              // Adjust
2836   2      #if(_USE_UD_LR_KEY_MSG)
2837   2              case VK_F_LEFT:
2838   2      #endif
2839   2              case VK_LEFT:        MOSDSizeAdjLR(1);        break;
2840   2      
2841   2              // Adjust
2842   2      #if(_USE_UD_LR_KEY_MSG)
2843   2              case VK_F_RIGHT:
2844   2      #endif
2845   2              case VK_RIGHT:       MOSDSizeAdjLR(0);        break;
2846   2                  
2847   2              // Other key
2848   2              default:             COthterKeyAction();      break;
2849   2          }
2850   1      }
2851          
2852          //----------------------------------------------------------------------------------------------------
2853          void MOSDSizeAdjMenu(void)
2854          {
2855   1          ucOsdState = MENU_SUB_OSD_SIZE;
2856   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
2857   1      }
2858          
2859          //----------------------------------------------------------------------------------------------------
2860          void MOSDSizeAdjLR(BYTE LR)
2861          {   
2862   1          CClearMsg(_CLEAR_MSG_ONLY);
2863   1      
2864   1          LR = _GET_OSD_SIZE();
2865   1          
2866   1          LR = 1 - LR;
2867   1      
2868   1          // Disable OSD
2869   1          CTimerWaitForEvent(_EVENT_DEN_STOP);
2870   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~_BIT0, 0x00);
2871   1          
2872   1          _SET_OSD_SIZE(LR);
2873   1           if (_GET_OSD_SIZE()) 
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 48  

2874   1              OSDPosition(_OSD_DOUBLE_WIDTH(_MAIN_WINDOW_WIDTH), _OSD_DOUBLE_HEIGHT(_MAIN_WINDOW_HEIGHT), stOsdU
             -serData.OsdHPos+(_MAINMENU_DOUBLE_H_OFFSET), stOsdUserData.OsdVPos+(_MAINMENU_DOUBLE_V_OFFSET), 0x03);
2875   1            else
2876   1              OSDPosition(_MAIN_WINDOW_WIDTH, _MAIN_WINDOW_HEIGHT, stOsdUserData.OsdHPos+(_MAINMENU_H_OFFSET), s
             -tOsdUserData.OsdVPos+(_MAINMENU_V_OFFSET), 0x03);
2877   1          SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
2878   1          CSetOSDTransAndSize();
2879   1      
2880   1          // Enable OSD
2881   1          CTimerWaitForEvent(_EVENT_DEN_STOP);
2882   1          CScalerSetBit(_OVERLAY_CTRL_6C, ~_BIT0, _BIT0);
2883   1      
2884   1          CenterTextout((BYTE *)sOn_Off[LR][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
2885   1      
2886   1          ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
2887   1      }
2888          
2889          #endif
2890          
2891          //----------------------------------------------------------------------------------------------------
2892          //   Sound Sub item
2893          void MSoundSubItemProc(void)
2894          {
2895   1          switch(ucKeyMessage)
2896   1          {
2897   2              // Select item
2898   2      #if(_USE_UD_LR_KEY_MSG)
2899   2              case VK_F_LEFT:
2900   2              case VK_F_RIGHT:
2901   2              //    MSoundSubItemMenu();
2902   2                //  break;
2903   2      #endif
2904   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
2905   2              case VK_RIGHT:        
2906   2              case VK_LEFT:     
2907   2      #else
                      case VK_MENU:      
              #endif
2910   2              case VK_IR_OK:      
2911   2                              MSoundSubItemMenu();               break;
2912   2      
2913   2              // Move item
2914   2      #if(_USE_UD_LR_KEY_MSG)
2915   2              case VK_F_UP:
2916   2      #endif
2917   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_RIGHT:       
              #endif
2920   2                              MSoundSubItemLR(1);                break;
2921   2      
2922   2              // Move item
2923   2      #if(_USE_UD_LR_KEY_MSG)
2924   2              case VK_F_DOWN:
2925   2      #endif
2926   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_LEFT:       
              #endif
2929   2                              MSoundSubItemLR(0);                break;
2930   2      
2931   2              // Exit item
2932   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
2933   2              case VK_ENTER:      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 49  

2934   2      #endif
2935   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
2936   2              case VK_MENU:      
2937   2      #endif
2938   2              case VK_AUTO:
2939   2              case VK_IR_EXIT:
2940   2                  CExitToMainItem(MENU_MAIN_SOUND);  break; 
2941   2              // Other key
2942   2              default:             COthterKeyAction();                break;
2943   2          }
2944   1      }
2945          
2946          //----------------------------------------------------------------------------------------------------
2947          void MSoundSubItemMenu(void)
2948          {
2949   1          BYTE ucTemp = 0;
2950   1      
2951   1          CClearMsg(_CLEAR_AND_SELECT_SUB_ITEM);
2952   1      
2953   1          switch(ucOsdState)
2954   1          {
2955   2              case MENU_SUB_VOLUME:
2956   2                  ucTemp = stOsdUserData.Volume;
2957   2                  ucOsdState = MENU_SUB_VOL_ADJ;     
2958   2                  break;
2959   2      
2960   2              case MENU_SUB_MUTE: 
2961   2                  CenterTextout((BYTE *)sOn_Off[(GET_MUTE_STATE() == STATE_MUTEON) ? 1 : 0][GET_LANGUAGE], 14, _
             -MESSAGE_V_POSITION);
2962   2                  ucOsdState = MENU_SUB_MUTE_ADJ;     
2963   2                  return;  // Not show slider
2964   2      
2965   2      #if(_SOUND_PROCESSOR == _ENABLE)
                      case MENU_SUB_BALANCE:
                          ucTemp = stOsdUserData.Balance;
                          ucOsdState = MENU_SUB_BALANCE_ADJ;     
                          break;
              
                      case MENU_SUB_BASS:
                          ucTemp = stOsdUserData.Bass;
                          ucOsdState = MENU_SUB_BASS_ADJ;     
                          break;
              
                      case MENU_SUB_TREBLE:
                          ucTemp = stOsdUserData.Treble;
                          ucOsdState = MENU_SUB_TREBLE_ADJ;     
                          break;
              
                      case MENU_SUB_SRS:
                          ucTemp = stOsdUserData.SRS;
                          ucOsdState = MENU_SUB_SRS_ADJ;     
                          break;
              
                      case MENU_SUB_BBE:
                          ucTemp = stOsdUserData.BBE;
                          ucOsdState = MENU_SUB_BBE_ADJ;     
                          break;
              #endif
2991   2      
2992   2              case MENU_SUB_SOUND_CLOSE: 
2993   2                  CExitToMainItem(MENU_MAIN_SOUND);
2994   2                  return;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 50  

2995   2          }
2996   1      
2997   1          SLIDER1(ucTemp);
2998   1      }
2999          
3000          //----------------------------------------------------------------------------------------------------
3001          void MSoundSubItemLR(BYTE LR)
3002          {            
3003   1      #if(_SOUND_PROCESSOR == _DISABLE)
3004   1          BYTE ucTemp = 0;
3005   1      
3006   1      #else
              
                  ucOsdState = ValueInRangeChange(MENU_SUB_VOLUME, MENU_SUB_SOUND_CLOSE, ucOsdState, LR, 1);
              
              #endif
3011   1          
3012   1      #if(_SOUND_PROCESSOR == _DISABLE)
3013   1          if(LR)
3014   1          {
3015   2              switch(ucOsdState)
3016   2              {
3017   3                  case MENU_SUB_VOLUME:      ucOsdState = MENU_SUB_MUTE;        break;
3018   3      
3019   3      #if(_SOUND_PROCESSOR == _ENABLE)
                          case MENU_SUB_MUTE:        ucOsdState = MENU_SUB_BALANCE;     break;
                          case MENU_SUB_BALANCE:     ucOsdState = MENU_SUB_BASS;        break;
                          case MENU_SUB_BASS:        ucOsdState = MENU_SUB_TREBLE;      break;
                          case MENU_SUB_TREBLE:      ucOsdState = MENU_SUB_SRS;         break;
                          case MENU_SUB_SRS:         ucOsdState = MENU_SUB_BBE;         break;
                          case MENU_SUB_BBE:         ucOsdState = MENU_SUB_SOUND_CLOSE; break;
              #else
3027   3                  case MENU_SUB_MUTE:        ucOsdState = MENU_SUB_SOUND_CLOSE; break;
3028   3      #endif
3029   3      
3030   3                  case MENU_SUB_SOUND_CLOSE: ucOsdState = MENU_SUB_VOLUME;      break;
3031   3              }
3032   2          }
3033   1          else
3034   1          {
3035   2              switch(ucOsdState)
3036   2              {
3037   3                  case MENU_SUB_VOLUME:      ucOsdState = MENU_SUB_SOUND_CLOSE; break;
3038   3                  case MENU_SUB_MUTE:        ucOsdState = MENU_SUB_VOLUME;      break;
3039   3      
3040   3      #if(_SOUND_PROCESSOR == _ENABLE)
                          case MENU_SUB_BALANCE:     ucOsdState = MENU_SUB_MUTE;        break;
                          case MENU_SUB_BASS:        ucOsdState = MENU_SUB_BALANCE;     break;
                          case MENU_SUB_TREBLE:      ucOsdState = MENU_SUB_BASS;        break;
                          case MENU_SUB_SRS:         ucOsdState = MENU_SUB_TREBLE;      break;
                          case MENU_SUB_BBE:         ucOsdState = MENU_SUB_SRS;         break;
                          case MENU_SUB_SOUND_CLOSE: ucOsdState = MENU_SUB_BBE;         break;
              #else
3048   3                  case MENU_SUB_SOUND_CLOSE: ucOsdState = MENU_SUB_MUTE;        break;
3049   3      #endif
3050   3              }
3051   2          }   
3052   1          
3053   1          switch(ucOsdState)
3054   1          {      
3055   2              case MENU_SUB_VOLUME:  
3056   2                  ucTemp = 0;      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 51  

3057   2                  break;
3058   2      
3059   2              case MENU_SUB_MUTE: 
3060   2                  ucTemp = 1;      
3061   2                  break;
3062   2      
3063   2      #if(_SOUND_PROCESSOR == _ENABLE)
                      case MENU_SUB_BALANCE:
                          ucTemp = 2;      
                          break;
              
                      case MENU_SUB_BASS:
                          ucTemp = 3;      
                          break;
              
                      case MENU_SUB_TREBLE:
                          ucTemp = 4;      
                          break;
              
                      case MENU_SUB_SRS:
                          ucTemp = 5;      
                          break;
              
                      case MENU_SUB_BBE:
                          ucTemp = 6;      
                          break;
              #endif
3084   2      
3085   2              case MENU_SUB_SOUND_CLOSE:
3086   2      #if(_SOUND_PROCESSOR == _ENABLE)
                          ucTemp = 7;
              #else
3089   2                  ucTemp = 2;
3090   2      #endif      
3091   2                  break;
3092   2          }
3093   1           
3094   1          CGotoNextSubItem(ucTemp);
3095   1      
3096   1      #else
                     
                  CGotoNextSubItem(ucOsdState - MENU_SUB_VOLUME);
              
              #endif  // end #if(_SOUND_PROCESSOR == _DISABLE) 
3101   1      }
3102          //----------------------------------------------------------------------------------------------------
3103          
3104          #if(_VGA_COLOR_SUPPORT)
              void CClearVColorItem(void)
              {
                  OSDClear(1, 8, 1, 20, 0x00, BYTE_DISPLAY);
                  OSDClear(1, 8, 1, 20, 0x8C, BYTE_ATTRIB);
              }
              //----------------------------------------------------------------------------------------------------
              
              void CShowVColorSubItemWindow(BYTE ucItem)
              {
                  OSDClear(1, 8, 1, 20, 0x40, BYTE_COLOR);           // Clear item color
                  OSDClear((1+ucItem), 1, 1, 20, 0x10, BYTE_COLOR); // Set current sub item character color to white
              }
              //----------------------------------------------------------------------------------------------------
                    
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 52  

              void CShowVColorSelectSubItemWindow(BYTE ucItem)
              {
                  OSDClear(1, 8, 1, 20, 0x40, BYTE_COLOR);           // Clear item color
                  OSDClear((1+ucItem), 1, 1, 20, 0x20, BYTE_COLOR); // Set current sub item character color to red
              }       
              //----------------------------------------------------------------------------------------------------
              
              void CGotoAdjustVColor(void)
              {
                  CInitOSDMainFrame();
              
                   if (_GET_OSD_SIZE()) 
                      OSDPosition(_OSD_DOUBLE_WIDTH(_VCOLOR_WINDOW_WIDTH), _OSD_DOUBLE_HEIGHT(_VCOLOR_WINDOW_HEIGHT), _A
             -UTO_H_OFFSET, _AUTO_V_OFFSET, 0x03);
                    else
                     OSDPosition(_VCOLOR_WINDOW_WIDTH, _VCOLOR_WINDOW_HEIGHT, _AUTO_DOUBLE_H_OFFSET, _AUTO_DOUBLE_V_OFFS
             -ET, 0x03);
                   SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
              
                  // Set row height to 22, and col space to 0
                  DirectWOSDRam(1, 7, THE_BYTE1, 0xf0); // Row 1 ~ (1+7)
              
                  // Draw window
                  COsdFxDrawWindow(XSTART(_VCOLOR_WINDOW_H_POS), YSTART(_VCOLOR_WINDOW_V_POS), XEND(_VCOLOR_WINDOW_WIDTH
             -), YEND(_VCOLOR_WINDOW_HEIGHT), tOSD_MINI_WINDOW_STYLE);  
                  CDrawVividColorPage();
                  CShowVColorSubItemWindow(GET_SAC_DCC_TYPE());
              
                  COsdFxEnableOsd();
                  ucOsdState = MENU_SAC_DCC_TEXT + GET_SAC_DCC_TYPE();
              }
              
              //----------------------------------------------------------------------------------------------------
              // Vivid color page
              //----------------------------------------------------------------------------------------------------
              void MVividColorItemProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Select item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
                      case VK_F_RIGHT:
              #endif
                      case VK_MENU:        MVividColorItemMenu();                   break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
              #endif
                      case VK_RIGHT:        MVividColorItemLR(1);                    break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_DOWN:
              #endif
                      case VK_LEFT:       MVividColorItemLR(0);                    break;
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER:       
              #endif
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 53  

                      case VK_AUTO:
                          COsdFxDisableOsd();                      break;
                      // Other key
                      default:             COthterKeyAction();                      break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MVividColorItemMenu(void)
              {
                  BYTE ucTemp = 0;
              
                  switch(ucOsdState)
                  {
                      case MENU_SAC_DCC_TEXT:               // DCC <Text>
                      case MENU_SAC_DCC_MOVIE:              // DCC <Movie>
                      case MENU_SAC_DCC_GRAPHIC:            // DCC <Graphic>
                      case MENU_SAC_DCC_GAME:               // DCC <Game>
                      case MENU_SAC_DCC_NORMAL:             // DCC <Normal>
                      case MENU_SAC_DCC_CLOSE:              // DCC <Exit>
                          COsdFxDisableOsd();
                          break;
              
                      case MENU_SAC_DCC_USER:               // DCC <User>
                          CDrawVividColorSubPage();
                          ucOsdState = MENU_USER_ITEM_DCC;  
                          CShowVColorSubItemWindow(_FIRST_ITEM+2);
                          break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MVividColorItemLR(BYTE LR)
              {
                  ucOsdState = ValueInRangeChange(MENU_SAC_DCC_TEXT, MENU_SAC_DCC_CLOSE, ucOsdState, LR, 1);
                  
                  CShowVColorSubItemWindow(ucOsdState - MENU_SAC_DCC_TEXT);
              
                  switch(ucOsdState)
                  {
                      case MENU_SAC_DCC_TEXT:        CSetSACMode(_SAC_DCC_TEXT);    break;
                      case MENU_SAC_DCC_MOVIE:       CSetSACMode(_SAC_DCC_MOVIE);   break;
                      case MENU_SAC_DCC_GRAPHIC:     CSetSACMode(_SAC_DCC_GRAPHIC); break;
                      case MENU_SAC_DCC_GAME:        CSetSACMode(_SAC_DCC_GAME);    break;
                      case MENU_SAC_DCC_NORMAL:      CSetSACMode(_SAC_DCC_NORMAL);  break;
                      case MENU_SAC_DCC_USER:        CSetSACMode(_SAC_DCC_USER);    break;
                      case MENU_SAC_DCC_CLOSE:                                      break; // DCC <Exit>
                  }
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              //----------------------------------------------------------------------------------------------------
              // Vivid color sub page
              //----------------------------------------------------------------------------------------------------
              void MVividColorSubProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Select item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 54  

                      case VK_F_RIGHT:
              #endif
                      case VK_MENU:        MVividColorSubMenu();        break; 
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
              #endif
                      case VK_RIGHT:        MVividColorSubLR(1);         break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_DOWN:
              #endif
                      case VK_LEFT:       MVividColorSubLR(0);         break;
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER:      
                          CDrawVividColorPage();
                          ucOsdState = MENU_SAC_DCC_USER;
                          CShowVColorSubItemWindow(ucOsdState - MENU_SAC_DCC_TEXT);
              #endif
                          
                      // Other key
                      default:             COthterKeyAction();          break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MVividColorSubMenu(void)
              {
                  switch(ucOsdState)
                  {
                      case MENU_USER_ITEM_DCC:              // Vivid Color <DCC>
                          CDrawDCCPage();
                          ucOsdState = MENU_DCC_ITEM_TEXT + GET_MZ_DCC_TYPE();
                          CShowVColorSubItemWindow(GET_MZ_DCC_TYPE());
                          break;
              
                      case MENU_USER_ITEM_ICM:              // Vivid Color <ICM>
                          CDrawICMPage();
                          ucOsdState = MENU_ICM_ITEM_ON_OFF;
                          CShowVColorSubItemWindow(MENU_ICM_ITEM_ON_OFF - MENU_ICM_ITEM_RED);
                          break;
              
                      case MENU_USER_ITEM_COLOR:            // Vivid Color <Color>
                          CDrawVividSubColorPage();
                          ucOsdState = MENU_COLOR_ITEM_BRIGHTNESS;
                          CShowVColorSubItemWindow(_FIRST_ITEM);
                          break;
              
                      case MENU_USER_ITEM_CLOSE:            // Vivid Color <Exit>
                          CDrawVividColorPage();
                          ucOsdState = MENU_SAC_DCC_USER;
                          CShowVColorSubItemWindow(MENU_SAC_DCC_USER - MENU_SAC_DCC_TEXT);
                          break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MVividColorSubLR(BYTE LR)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 55  

              {
                  ucOsdState = ValueInRangeChange(MENU_USER_ITEM_DCC, MENU_USER_ITEM_CLOSE, ucOsdState, LR, 1);
                     
                  CShowVColorSubItemWindow(ucOsdState - MENU_USER_ITEM_DCC + 2);
              }
              
              //----------------------------------------------------------------------------------------------------
              // DCC page
              //----------------------------------------------------------------------------------------------------
              void MDCCAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Select item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
                      case VK_F_RIGHT:
              #endif
                      case VK_MENU:        MDCCAdjMenu();                         break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
              #endif
                      case VK_LEFT:        MDCCAdjLR(1);           break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_DOWN:
              #endif
                      case VK_RIGHT:       MDCCAdjLR(0);           break;
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER:       
                          CDrawVividColorSubPage();
                          ucOsdState = MENU_USER_ITEM_DCC;  
                          CShowVColorSubItemWindow(_FIRST_ITEM+2);
              #endif
                          
                      // Other key
                      default:             COthterKeyAction();     break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MDCCAdjMenu(void)
              {
                  switch(ucOsdState)
                  {
                      case MENU_DCC_ITEM_TEXT:
                      case MENU_DCC_ITEM_MOVIE:
                      case MENU_DCC_ITEM_GRAPHIC:
                      case MENU_DCC_ITEM_GAME:
                      case MENU_DCC_ITEM_NORMAL:
                          CDrawVividColorSubPage();
                          ucOsdState = MENU_USER_ITEM_DCC;  
                          CShowVColorSubItemWindow(_FIRST_ITEM+2);
                          break;
                  }
              }
              
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 56  

              //----------------------------------------------------------------------------------------------------
              void MDCCAdjLR(BYTE LR)
              {
                  BYTE uctemp =0;
              
                  ucOsdState = ValueInRangeChange(MENU_DCC_ITEM_TEXT, MENU_DCC_ITEM_NORMAL, ucOsdState, LR, 1);
                  
                  uctemp = ucOsdState - MENU_DCC_ITEM_TEXT;  // DCC type
                  SET_MZ_DCC_TYPE(uctemp);
              
                  if(uctemp < _MZ_DCC_NORMAL)
                  {
                      CAdjustFillDCCTable(tDCC_CONTROL[GET_MZ_DCC_TYPE()], tDCC_USERCURVE[GET_MZ_DCC_TYPE()]);
                      CScalerSetBit(_DCC_CTRL0_E4, ~_BIT7, _BIT7);
                  }
                  else if(uctemp == _MZ_DCC_NORMAL)
                  {
                      if (GET_MZ_ICM_ON_OFF_TYPE() == _OFF)
                         CAdjustDisableHLWindow(); 
              
                      CScalerSetBit(_DCC_CTRL0_E4, ~_BIT7, 0x00);
                  }
                 
                  CShowVColorSubItemWindow(ucOsdState - MENU_DCC_ITEM_TEXT);
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              //----------------------------------------------------------------------------------------------------
              // ICM page
              //----------------------------------------------------------------------------------------------------
              void MICMItemProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Select item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
                      case VK_F_RIGHT:
              #endif
                      case VK_MENU:        MICMItemMenu();                          break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
              #endif
                      case VK_LEFT:        MICMItemLR(1);          break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_DOWN:
              #endif
                      case VK_RIGHT:       MICMItemLR(0);          break;
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER:       
                          CDrawVividColorSubPage();
                          ucOsdState = MENU_USER_ITEM_ICM;  
                          CShowVColorSubItemWindow(3);
              #endif
                          
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 57  

                      // Other key
                      default:             COthterKeyAction();     break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MICMItemMenu(void)
              {
                  BYTE ucHue = 0;
                  BYTE ucSat = 0;
              
                  switch(ucOsdState)
                  {
                      case MENU_ICM_ITEM_RED: 
                          ucHue = stOsdUserData.MZICMRedHue;
                          ucSat = stOsdUserData.MZICMRedSat;
                          ucOsdState = MENU_ICM_SUB_R_HUE;
                          break;
              
                      case MENU_ICM_ITEM_GREEN:      
                          ucHue = stOsdUserData.MZICMGreenHue;
                          ucSat = stOsdUserData.MZICMGreenSat;
                          ucOsdState = MENU_ICM_SUB_G_HUE;     
                          break;
              
                      case MENU_ICM_ITEM_BLUE:       
                          ucHue = stOsdUserData.MZICMBlueHue;
                          ucSat = stOsdUserData.MZICMBlueSat;
                          ucOsdState = MENU_ICM_SUB_B_HUE;     
                          break;
                          
                      case MENU_ICM_ITEM_YELLOW: 
                          ucHue = stOsdUserData.MZICMYellowHue;
                          ucSat = stOsdUserData.MZICMYellowSat;
                          ucOsdState = MENU_ICM_SUB_Y_HUE;
                          break;
              
                      case MENU_ICM_ITEM_CYAN:      
                          ucHue = stOsdUserData.MZICMCyanHue;
                          ucSat = stOsdUserData.MZICMCyanSat;
                          ucOsdState = MENU_ICM_SUB_C_HUE;     
                          break;
              
                      case MENU_ICM_ITEM_MAGENTA:       
                          ucHue = stOsdUserData.MZICMMagentaHue;
                          ucSat = stOsdUserData.MZICMMagentaSat;
                          ucOsdState = MENU_ICM_SUB_M_HUE;     
                          break;
                          
                      case MENU_ICM_ITEM_ON_OFF:
                          if (GET_MZ_ICM_ON_OFF_TYPE())  // ICM on
                          {
                              SET_MZ_ICM_ON_OFF_TYPE(_OFF);
                              CScalerSetBit(_ICM_CTRL_E0, ~_BIT7, 0x00);
                          }
                          else
                          {
                              SET_MZ_ICM_ON_OFF_TYPE(_ON);
                              CScalerSetBit(_ICM_CTRL_E0, ~_BIT7, _BIT7);
                          }
                          CenterTextout((BYTE *)sOn_Off[GET_MZ_ICM_ON_OFF_TYPE()][GET_LANGUAGE], 8, 7);
                          OutputChar(0x00);
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 58  

                          ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
                          return;
              
                      case MENU_ICM_ITEM_CLOSE:
                          CDrawVividColorSubPage();
                          ucOsdState = MENU_USER_ITEM_ICM;  
                          CShowVColorSubItemWindow(3);
                          return;
                  }
              
                  CDrawICMColorAdjPage();
                  CShowVColorSubItemWindow(_FIRST_ITEM+1);
              
                  Gotoxy(11,2,BYTE_DISPLAY);         
                  CShowNumber(ucHue, 0);
                  Gotoxy(14,4,BYTE_DISPLAY);         
                  CShowNumber(ucSat, 0);
              }
              
              //----------------------------------------------------------------------------------------------------
              void MICMItemLR(BYTE LR)
              {
                  if (GET_MZ_ICM_ON_OFF_TYPE() == _OFF && (ucOsdState == MENU_ICM_ITEM_ON_OFF || ucOsdState == MENU_ICM_
             -ITEM_CLOSE))
                  {
                      ucOsdState = (ucOsdState == MENU_ICM_ITEM_ON_OFF) ? MENU_ICM_ITEM_CLOSE : MENU_ICM_ITEM_ON_OFF;
                  }
                  else
                      ucOsdState = ValueInRangeChange(MENU_ICM_ITEM_RED, MENU_ICM_ITEM_CLOSE, ucOsdState, LR, 1);
              
                    
                  CShowVColorSubItemWindow(ucOsdState - MENU_ICM_ITEM_RED);
              }
              
              //----------------------------------------------------------------------------------------------------
              // ICM R/G/B item page
              //----------------------------------------------------------------------------------------------------
              void MICMSubRGBItemAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Select item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
                      case VK_F_RIGHT:
              #endif
                      case VK_MENU:        MICMSubRGBItemAdjMenu();     break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
              #endif
                      case VK_LEFT:        MICMSubRGBItemAdjLR(1);      break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_DOWN:
              #endif
                      case VK_RIGHT:       MICMSubRGBItemAdjLR(0);      break;
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 59  

                      case VK_ENTER:       
                          switch(ucOsdState)
                          {
                              //-------------  Red --------------
                              case MENU_ICM_SUB_R_HUE:
                              case MENU_ICM_SUB_R_SAT:
                              case MENU_ICM_SUB_R_CLOSE:
                                  CExitToICMPage(MENU_ICM_ITEM_RED);
                                  break;
                      
                              //------------- Green -------------
                              case MENU_ICM_SUB_G_HUE:
                              case MENU_ICM_SUB_G_SAT:
                              case MENU_ICM_SUB_G_CLOSE:
                                  CExitToICMPage(MENU_ICM_ITEM_GREEN);
                                  break;
                      
                              //-------------- Blue -------------
                              case MENU_ICM_SUB_B_HUE:
                              case MENU_ICM_SUB_B_SAT:
                              case MENU_ICM_SUB_B_CLOSE:
                                  CExitToICMPage(MENU_ICM_ITEM_BLUE);
                                  break;
              
                              //------------ Yellow -------------
                              case MENU_ICM_SUB_Y_HUE:
                              case MENU_ICM_SUB_Y_SAT:
                              case MENU_ICM_SUB_Y_CLOSE:
                                  CExitToICMPage(MENU_ICM_ITEM_YELLOW);
                                  break;
                      
                              //-------------_ Cyan -------------
                              case MENU_ICM_SUB_C_HUE:
                              case MENU_ICM_SUB_C_SAT:
                              case MENU_ICM_SUB_C_CLOSE:
                                  CExitToICMPage(MENU_ICM_ITEM_CYAN);
                                  break;
                      
                              //------------ Magenta ------------
                              case MENU_ICM_SUB_M_HUE:
                              case MENU_ICM_SUB_M_SAT:
                              case MENU_ICM_SUB_M_CLOSE:
                                  CExitToICMPage(MENU_ICM_ITEM_MAGENTA);
                                  break;
                          }
              #endif
                          
                      // Other key
                      default:             COthterKeyAction();          break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void CExitToICMPage(const BYTE ucExitToItem)
              {
                  CDrawICMPage();
                  ucOsdState = ucExitToItem;
                  CShowVColorSubItemWindow(ucOsdState - MENU_ICM_ITEM_RED);
              }
              
              void MICMSubRGBItemAdjMenu(void)
              {
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 60  

                  BYTE ucTemp       = 0;
              
                  switch(ucOsdState)
                  {
                      //-------------  Red --------------------
                      case MENU_ICM_SUB_R_HUE:
                          ucOsdState   = MENU_ICM_R_HUE_ADJ;
                          ucTemp       = 1;
                          break;
              
                      case MENU_ICM_SUB_R_SAT:
                          ucOsdState   = MENU_ICM_R_SAT_ADJ;
                          ucTemp       = 3;
                          break;
              
                      case MENU_ICM_SUB_R_CLOSE:
                          CExitToICMPage(MENU_ICM_ITEM_RED);
                          return;
              
                      //------------- Green -------------
                      case MENU_ICM_SUB_G_HUE:
                          ucOsdState   = MENU_ICM_G_HUE_ADJ;
                          ucTemp       = 1;
                          break;
              
                      case MENU_ICM_SUB_G_SAT:
                          ucOsdState   = MENU_ICM_G_SAT_ADJ;
                          ucTemp       = 3;
                          break;
              
                      case MENU_ICM_SUB_G_CLOSE:
                          CExitToICMPage(MENU_ICM_ITEM_GREEN);
                          return;
              
                      //-------------- Blue ---------------
                      case MENU_ICM_SUB_B_HUE:
                          ucOsdState   = MENU_ICM_B_HUE_ADJ;
                          ucTemp       = 1;
                          break;
              
                      case MENU_ICM_SUB_B_SAT:
                          ucOsdState   = MENU_ICM_B_SAT_ADJ;
                          ucTemp       = 3;
                          break;
              
                      case MENU_ICM_SUB_B_CLOSE:
                          CExitToICMPage(MENU_ICM_ITEM_BLUE);
                          return;
              
                      //------------- Yellow ---------------
                      case MENU_ICM_SUB_Y_HUE:
                          ucOsdState   = MENU_ICM_Y_HUE_ADJ;
                          ucTemp       = 1;
                          break;
              
                      case MENU_ICM_SUB_Y_SAT:
                          ucOsdState   = MENU_ICM_Y_SAT_ADJ;
                          ucTemp       = 3;
                          break;
              
                      case MENU_ICM_SUB_Y_CLOSE:
                          CExitToICMPage(MENU_ICM_ITEM_YELLOW);
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 61  

                          return;
              
                      //-------------- Cyan ---------------
                      case MENU_ICM_SUB_C_HUE:
                          ucOsdState   = MENU_ICM_C_HUE_ADJ;
                          ucTemp       = 1;
                          break;
              
                      case MENU_ICM_SUB_C_SAT:
                          ucOsdState   = MENU_ICM_C_SAT_ADJ;
                          ucTemp       = 3;
                          break;
              
                      case MENU_ICM_SUB_C_CLOSE:
                          CExitToICMPage(MENU_ICM_ITEM_CYAN);
                          return;
              
                      //------------- Magenta --------------
                      case MENU_ICM_SUB_M_HUE:
                          ucOsdState   = MENU_ICM_M_HUE_ADJ;
                          ucTemp       = 1;
                          break;
              
                      case MENU_ICM_SUB_M_SAT:
                          ucOsdState   = MENU_ICM_M_SAT_ADJ;
                          ucTemp       = 3;
                          break;
              
                      case MENU_ICM_SUB_M_CLOSE:
                          CExitToICMPage(MENU_ICM_ITEM_MAGENTA);
                          return;
                  }
              
                  CShowVColorSelectSubItemWindow(ucTemp); 
              }
              
              //----------------------------------------------------------------------------------------------------
              void MICMSubRGBItemAdjLR(BYTE LR)
              {
                  BYTE ucTemp = 0;
              
                  if(LR)
                  {
                      switch(ucOsdState)
                      {
                          case MENU_ICM_SUB_R_HUE:           ucOsdState = MENU_ICM_SUB_R_SAT;     break;
                          case MENU_ICM_SUB_R_SAT:           ucOsdState = MENU_ICM_SUB_R_CLOSE;   break;
                          case MENU_ICM_SUB_R_CLOSE:         ucOsdState = MENU_ICM_SUB_R_HUE;     break;
              
                          case MENU_ICM_SUB_G_HUE:           ucOsdState = MENU_ICM_SUB_G_SAT;     break;
                          case MENU_ICM_SUB_G_SAT:           ucOsdState = MENU_ICM_SUB_G_CLOSE;   break;
                          case MENU_ICM_SUB_G_CLOSE:         ucOsdState = MENU_ICM_SUB_G_HUE;     break;
              
                          case MENU_ICM_SUB_B_HUE:           ucOsdState = MENU_ICM_SUB_B_SAT;     break;
                          case MENU_ICM_SUB_B_SAT:           ucOsdState = MENU_ICM_SUB_B_CLOSE;   break;
                          case MENU_ICM_SUB_B_CLOSE:         ucOsdState = MENU_ICM_SUB_B_HUE;     break;
              
                          case MENU_ICM_SUB_Y_HUE:           ucOsdState = MENU_ICM_SUB_Y_SAT;     break;
                          case MENU_ICM_SUB_Y_SAT:           ucOsdState = MENU_ICM_SUB_Y_CLOSE;   break;
                          case MENU_ICM_SUB_Y_CLOSE:         ucOsdState = MENU_ICM_SUB_Y_HUE;     break;
              
                          case MENU_ICM_SUB_C_HUE:           ucOsdState = MENU_ICM_SUB_C_SAT;     break;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 62  

                          case MENU_ICM_SUB_C_SAT:           ucOsdState = MENU_ICM_SUB_C_CLOSE;   break;
                          case MENU_ICM_SUB_C_CLOSE:         ucOsdState = MENU_ICM_SUB_C_HUE;     break;
              
                          case MENU_ICM_SUB_M_HUE:           ucOsdState = MENU_ICM_SUB_M_SAT;     break;
                          case MENU_ICM_SUB_M_SAT:           ucOsdState = MENU_ICM_SUB_M_CLOSE;   break;
                          case MENU_ICM_SUB_M_CLOSE:         ucOsdState = MENU_ICM_SUB_M_HUE;     break;
                      }
                  }
                  else
                  {
                      switch(ucOsdState)
                      {
                          case MENU_ICM_SUB_R_HUE:           ucOsdState = MENU_ICM_SUB_R_CLOSE;   break;
                          case MENU_ICM_SUB_R_SAT:           ucOsdState = MENU_ICM_SUB_R_HUE;     break;
                          case MENU_ICM_SUB_R_CLOSE:         ucOsdState = MENU_ICM_SUB_R_SAT;     break;
              
                          case MENU_ICM_SUB_G_HUE:           ucOsdState = MENU_ICM_SUB_G_CLOSE;   break;
                          case MENU_ICM_SUB_G_SAT:           ucOsdState = MENU_ICM_SUB_G_HUE;     break;
                          case MENU_ICM_SUB_G_CLOSE:         ucOsdState = MENU_ICM_SUB_G_SAT;     break;
              
                          case MENU_ICM_SUB_B_HUE:           ucOsdState = MENU_ICM_SUB_B_CLOSE;   break;
                          case MENU_ICM_SUB_B_SAT:           ucOsdState = MENU_ICM_SUB_B_HUE;     break;
                          case MENU_ICM_SUB_B_CLOSE:         ucOsdState = MENU_ICM_SUB_B_SAT;     break;
              
                          case MENU_ICM_SUB_Y_HUE:           ucOsdState = MENU_ICM_SUB_Y_CLOSE;   break;
                          case MENU_ICM_SUB_Y_SAT:           ucOsdState = MENU_ICM_SUB_Y_HUE;     break;
                          case MENU_ICM_SUB_Y_CLOSE:         ucOsdState = MENU_ICM_SUB_Y_SAT;     break;
              
                          case MENU_ICM_SUB_C_HUE:           ucOsdState = MENU_ICM_SUB_C_CLOSE;   break;
                          case MENU_ICM_SUB_C_SAT:           ucOsdState = MENU_ICM_SUB_C_HUE;     break;
                          case MENU_ICM_SUB_C_CLOSE:         ucOsdState = MENU_ICM_SUB_C_SAT;     break;
              
                          case MENU_ICM_SUB_M_HUE:           ucOsdState = MENU_ICM_SUB_M_CLOSE;   break;
                          case MENU_ICM_SUB_M_SAT:           ucOsdState = MENU_ICM_SUB_M_HUE;     break;
                          case MENU_ICM_SUB_M_CLOSE:         ucOsdState = MENU_ICM_SUB_M_SAT;     break;
                      }
                  }
                  
                  switch(ucOsdState)
                  {      
                      case MENU_ICM_SUB_R_HUE:
                      case MENU_ICM_SUB_G_HUE:
                      case MENU_ICM_SUB_B_HUE:
                      case MENU_ICM_SUB_Y_HUE:
                      case MENU_ICM_SUB_C_HUE:
                      case MENU_ICM_SUB_M_HUE:
                          ucTemp = 1;      
                          break;
              
                      case MENU_ICM_SUB_R_SAT:
                      case MENU_ICM_SUB_G_SAT:
                      case MENU_ICM_SUB_B_SAT:
                      case MENU_ICM_SUB_Y_SAT:
                      case MENU_ICM_SUB_C_SAT:
                      case MENU_ICM_SUB_M_SAT:
                          ucTemp = 3;      
                          break;
              
                      case MENU_ICM_SUB_R_CLOSE:
                      case MENU_ICM_SUB_G_CLOSE:
                      case MENU_ICM_SUB_B_CLOSE:
                      case MENU_ICM_SUB_Y_CLOSE:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 63  

                      case MENU_ICM_SUB_C_CLOSE:
                      case MENU_ICM_SUB_M_CLOSE:
                          ucTemp = 5;      
                          break;
                  }   
                  
                  CShowVColorSubItemWindow(ucTemp);
              }
              
              //----------------------------------------------------------------------------------------------------
              // ICM R/G/B color item page
              //----------------------------------------------------------------------------------------------------
              void MICMSubRGBColorAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MICMSubRGBColorAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_MENU:        MICMSubRGBColorAdjMenu();     break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MICMSubRGBColorAdjLR(1);      break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MICMSubRGBColorAdjLR(0);      break;
                          
                      // Other key
                      default:             COthterKeyAction();           break;
                  }
              }
              //----------------------------------------------------------------------------------------------------
              
              void CExitAdjState(const BYTE ucSubItem, const BYTE ucBarPos)
              {
                  ucOsdState = ucSubItem;
                  CShowVColorSubItemWindow(ucBarPos); 
              }
              //----------------------------------------------------------------------------------------------------
              
              void MICMSubRGBColorAdjMenu(void)
              {
                  CLR_KEYREPEATENABLE();
              
                  switch(ucOsdState)
                  {
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 64  

                      case MENU_ICM_R_HUE_ADJ:
                          CExitAdjState(MENU_ICM_SUB_R_HUE, 1);
                          break;
              
                      case MENU_ICM_R_SAT_ADJ:
                          CExitAdjState(MENU_ICM_SUB_R_SAT, 3);
                          break;
              
                      case MENU_ICM_G_HUE_ADJ:
                          CExitAdjState(MENU_ICM_SUB_G_HUE, 1);
                          break;
              
                      case MENU_ICM_G_SAT_ADJ:
                          CExitAdjState(MENU_ICM_SUB_G_SAT, 3);
                          break;
              
                      case MENU_ICM_B_HUE_ADJ:
                          CExitAdjState(MENU_ICM_SUB_B_HUE, 1);
                          break;
              
                      case MENU_ICM_B_SAT_ADJ:
                          CExitAdjState(MENU_ICM_SUB_B_SAT, 3);
                          break;
              
                      case MENU_ICM_Y_HUE_ADJ:
                          CExitAdjState(MENU_ICM_SUB_Y_HUE, 1);
                          break;
              
                      case MENU_ICM_Y_SAT_ADJ:
                          CExitAdjState(MENU_ICM_SUB_Y_SAT, 3);
                          break;
              
                      case MENU_ICM_C_HUE_ADJ:
                          CExitAdjState(MENU_ICM_SUB_C_HUE, 1);
                          break;
              
                      case MENU_ICM_C_SAT_ADJ:
                          CExitAdjState(MENU_ICM_SUB_C_SAT, 3);
                          break;
              
                      case MENU_ICM_M_HUE_ADJ:
                          CExitAdjState(MENU_ICM_SUB_M_HUE, 1);
                          break;
              
                      case MENU_ICM_M_SAT_ADJ:
                          CExitAdjState(MENU_ICM_SUB_M_SAT, 3);
                          break;
                  }
              }
              //----------------------------------------------------------------------------------------------------
              
              void MICMSubRGBColorAdjLR(BYTE LR)
              {             
                  BYTE ucAdjResult = 0;
                  BYTE ucAdjMode   = 0;
                  BYTE ucShowPos   = 0;
              
                  SET_KEYREPEATENABLE();
              
                  switch(ucOsdState)
                  {
                  case MENU_ICM_R_HUE_ADJ:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 65  

                      stOsdUserData.MZICMRedHue = ValueInRangeChange(_MZ_ICM_RED_HUE_MIN, _MZ_ICM_RED_HUE_MAX, stOsdUser
             -Data.MZICMRedHue, LR, 0);
                      ucAdjMode   = _V_RED;
                      ucAdjResult = stOsdUserData.MZICMRedHue;
                      break;
              
                  case MENU_ICM_R_SAT_ADJ:
                      stOsdUserData.MZICMRedSat = ValueInRangeChange(_MZ_ICM_RED_SAT_MIN, _MZ_ICM_RED_SAT_MAX, stOsdUser
             -Data.MZICMRedSat, LR, 0);
                      ucAdjMode   = _V_RED;
                      ucAdjResult = stOsdUserData.MZICMRedSat;
                      ucShowPos   = 1;
                      break;
              
                  case MENU_ICM_G_HUE_ADJ:
                      stOsdUserData.MZICMGreenHue = ValueInRangeChange(_MZ_ICM_GREEN_HUE_MIN, _MZ_ICM_GREEN_HUE_MAX, stO
             -sdUserData.MZICMGreenHue, LR, 0);
                      ucAdjMode   = _V_GREEN;
                      ucAdjResult = stOsdUserData.MZICMGreenHue;
                      break;
              
                  case MENU_ICM_G_SAT_ADJ:
                      stOsdUserData.MZICMGreenSat = ValueInRangeChange(_MZ_ICM_GREEN_SAT_MIN, _MZ_ICM_GREEN_SAT_MAX, stO
             -sdUserData.MZICMGreenSat, LR, 0);
                      ucAdjMode   = _V_GREEN;
                      ucAdjResult = stOsdUserData.MZICMGreenSat;
                      ucShowPos   = 1;
                      break;
              
                  case MENU_ICM_B_HUE_ADJ:
                      stOsdUserData.MZICMBlueHue = ValueInRangeChange(_MZ_ICM_BLUE_HUE_MIN, _MZ_ICM_BLUE_HUE_MAX, stOsdU
             -serData.MZICMBlueHue, LR, 0);
                      ucAdjMode   = _V_BLUE;
                      ucAdjResult = stOsdUserData.MZICMBlueHue;
                      break;
              
                  case MENU_ICM_B_SAT_ADJ:
                      stOsdUserData.MZICMBlueSat = ValueInRangeChange(_MZ_ICM_BLUE_SAT_MIN, _MZ_ICM_BLUE_SAT_MAX, stOsdU
             -serData.MZICMBlueSat, LR, 0);
                      ucAdjMode   = _V_BLUE;
                      ucAdjResult = stOsdUserData.MZICMBlueSat;
                      ucShowPos   = 1;
                      break;
              
                  case MENU_ICM_Y_HUE_ADJ:
                      stOsdUserData.MZICMYellowHue = ValueInRangeChange(_MZ_ICM_YELLOW_HUE_MIN, _MZ_ICM_YELLOW_HUE_MAX, 
             -stOsdUserData.MZICMYellowHue, LR, 0);
                      ucAdjMode   = _V_YELLOW;
                      ucAdjResult = stOsdUserData.MZICMYellowHue;
                      break;
              
                  case MENU_ICM_Y_SAT_ADJ:
                      stOsdUserData.MZICMYellowSat = ValueInRangeChange(_MZ_ICM_RED_SAT_MIN, _MZ_ICM_RED_SAT_MAX, stOsdU
             -serData.MZICMYellowSat, LR, 0);
                      ucAdjMode   = _V_YELLOW;
                      ucAdjResult = stOsdUserData.MZICMYellowSat;
                      ucShowPos   = 1;
                      break;
              
                  case MENU_ICM_C_HUE_ADJ:
                      stOsdUserData.MZICMCyanHue = ValueInRangeChange(_MZ_ICM_CYAN_HUE_MIN, _MZ_ICM_CYAN_HUE_MAX, stOsdU
             -serData.MZICMCyanHue, LR, 0);
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 66  

                      ucAdjMode   = _V_CYAN;
                      ucAdjResult = stOsdUserData.MZICMCyanHue;
                      break;
              
                  case MENU_ICM_C_SAT_ADJ:
                      stOsdUserData.MZICMCyanSat = ValueInRangeChange(_MZ_ICM_CYAN_SAT_MIN, _MZ_ICM_CYAN_SAT_MAX, stOsdU
             -serData.MZICMCyanSat, LR, 0);
                      ucAdjMode   = _V_CYAN;
                      ucAdjResult = stOsdUserData.MZICMCyanSat;
                      ucShowPos   = 1;
                      break;
              
                  case MENU_ICM_M_HUE_ADJ:
                      stOsdUserData.MZICMMagentaHue = ValueInRangeChange(_MZ_ICM_MAGENTA_HUE_MIN, _MZ_ICM_MAGENTA_HUE_MA
             -X, stOsdUserData.MZICMMagentaHue, LR, 0);
                      ucAdjMode   = _V_MAGENTA;
                      ucAdjResult = stOsdUserData.MZICMMagentaHue;
                      break;
              
                  case MENU_ICM_M_SAT_ADJ:
                      stOsdUserData.MZICMMagentaSat = ValueInRangeChange(_MZ_ICM_MAGENTA_SAT_MIN, _MZ_ICM_MAGENTA_SAT_MA
             -X, stOsdUserData.MZICMMagentaSat, LR, 0);
                      ucAdjMode   = _V_MAGENTA;
                      ucAdjResult = stOsdUserData.MZICMMagentaSat;
                      ucShowPos   = 1;
                      break;
                  } 
               
                  CAdjustMZHueSat(ucAdjMode);
              
                  if (0 == ucShowPos)  // Adj HUE
                  {
                      Gotoxy(11, 2, BYTE_DISPLAY);         
                      CShowNumber(ucAdjResult, 0);
                      OutputChar(' ');
                  }
                  else
                  {
                      Gotoxy(14, 4, BYTE_DISPLAY);         
                      CShowNumber(ucAdjResult, 0);
                      OutputChar(' ');
                  }
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              //----------------------------------------------------------------------------------------------------
              // DCC Color adj proc
              //----------------------------------------------------------------------------------------------------
              void MDCCColorAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Select item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
                      case VK_F_RIGHT:
              #endif
                      case VK_MENU:        MDCCColorAdjMenu();       break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 67  

                      case VK_F_UP:
              #endif
                      case VK_LEFT:        MDCCColorAdjLR(1);        break;
              
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_DOWN:
              #endif
                      case VK_RIGHT:       MDCCColorAdjLR(0);        break;
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER:
                          CDrawVividColorSubPage();
                          ucOsdState = MENU_USER_ITEM_COLOR;  
                          CShowVColorSubItemWindow(_FIRST_ITEM+4);
                          break;
              #endif
                          
                      // Other key
                      default:             COthterKeyAction();         break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MDCCColorAdjMenu(void)
              {
                  switch(ucOsdState)
                  {      
                      case MENU_COLOR_ITEM_BRIGHTNESS:
                          ucOsdState = MENU_COLOR_ITEM_BRIGHT_ADJ;
                          break;
              
                      case MENU_COLOR_ITEM_CONTRAST:
                          ucOsdState = MENU_COLOR_ITEM_CON_ADJ;
                          break;
              
                      case MENU_COLOR_ITEM_PEAKING:
                          ucOsdState = MENU_COLOR_ITEM_PEAK_ADJ;
                          break;
              
                      case MENU_COLOR_ITEM_CLOSE:
                          CDrawVividColorSubPage();
                          ucOsdState = MENU_USER_ITEM_COLOR;  
                          CShowVColorSubItemWindow(_FIRST_ITEM+4);
                          return;
                  }  
              
                  CShowVColorSelectSubItemWindow((ucOsdState - MENU_COLOR_ITEM_BRIGHT_ADJ)*2);
              }
              
              //----------------------------------------------------------------------------------------------------
              void MDCCColorAdjLR(BYTE  LR)
              {   
                  ucOsdState = ValueInRangeChange(MENU_COLOR_ITEM_BRIGHTNESS, MENU_COLOR_ITEM_CLOSE, ucOsdState, LR, 1);
              
                  CShowVColorSubItemWindow((ucOsdState - MENU_COLOR_ITEM_BRIGHTNESS)*2);
              }
              
              //----------------------------------------------------------------------------------------------------
              // Vivid color bright/contrast adj proc
              //----------------------------------------------------------------------------------------------------
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 68  

              void MDCCColorBCAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MDCCColorBCAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_MENU:        MDCCColorBCAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MDCCColorBCAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MDCCColorBCAdjLR(0);        break;
                         
                      // Other key
                      default:             COthterKeyAction();         break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MDCCColorBCAdjMenu(void)
              {
                  CLR_KEYREPEATENABLE();
              
                  switch(ucOsdState)
                  {
                      case MENU_COLOR_ITEM_BRIGHT_ADJ:   CExitAdjState(MENU_COLOR_ITEM_BRIGHTNESS, 0);  break;
                      case MENU_COLOR_ITEM_CON_ADJ:      CExitAdjState(MENU_COLOR_ITEM_CONTRAST, 2);    break;
                      case MENU_COLOR_ITEM_PEAK_ADJ:     CExitAdjState(MENU_COLOR_ITEM_PEAKING, 4);     break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MDCCColorBCAdjLR(BYTE  LR)
              {    
                  SET_KEYREPEATENABLE();
              
                  switch(ucOsdState)
                  {
                      case MENU_COLOR_ITEM_BRIGHT_ADJ:
                          stOsdUserData.MZBright = ValueInRangeChange(0, 255, stOsdUserData.MZBright, LR, 0);
                          CAdjustHLWindowBrightness(stOsdUserData.MZBright);
              
                          Gotoxy(13, 1, BYTE_DISPLAY);         
                          CShowNumber(stOsdUserData.MZBright, 0);
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 69  

                          OutputChar(' ');
                          break;
              
                      case MENU_COLOR_ITEM_CON_ADJ:
                          stOsdUserData.MZContrast = ValueInRangeChange(0, 255, stOsdUserData.MZContrast, LR, 0);
                          CAdjustHLWindowContrast(stOsdUserData.MZContrast);
              
                          Gotoxy(12, 3, BYTE_DISPLAY);         
                          CShowNumber(stOsdUserData.MZContrast, 0);
                          OutputChar(' ');
                          break;
              
                      case MENU_COLOR_ITEM_PEAK_ADJ:
                          stOsdUserData.MZPeaking = ValueInRangeChange(_MZ_COLOR_PEAKING_MIN, _MZ_COLOR_PEAKING_MAX, stO
             -sdUserData.MZPeaking, LR, 0);
                          CAdjustHLWindowPeaking(stOsdUserData.MZPeaking);
              
                          Gotoxy(12, 5, BYTE_DISPLAY);         
                          CShowNumber(stOsdUserData.MZPeaking, 0);
                          OutputChar(' ');
                          break;
                  }      
              
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              #endif
4183          
4184          //----------------------------------------------------------------------------------------------------
4185          //   Other Sub item
4186          void MOtherSubItemProc(void)
4187          {
4188   1          switch(ucKeyMessage)
4189   1          {
4190   2              // Select item
4191   2      #if(_USE_UD_LR_KEY_MSG)
4192   2              case VK_F_LEFT:
4193   2              case VK_F_RIGHT:
4194   2      #endif
4195   2      #if(_KEY_TYPE_OSD007==_7KEY_SUPPORT)
4196   2              case VK_RIGHT:        
4197   2              case VK_LEFT:     
4198   2      #else
                      case VK_MENU:       
              #endif
4201   2              case VK_IR_OK:       
4202   2                              MOtherSubItemMenu();               break;
4203   2      
4204   2              // Move item
4205   2      #if(_USE_UD_LR_KEY_MSG)
4206   2              case VK_F_UP:
4207   2      #endif
4208   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
                      case VK_RIGHT:        
              #endif
4211   2                              MOtherSubItemLR(1);                break;
4212   2      
4213   2              // Move item
4214   2      #if(_USE_UD_LR_KEY_MSG)
4215   2              case VK_F_DOWN:
4216   2      #endif
4217   2      #if(_KEY_TYPE_OSD007!=_7KEY_SUPPORT)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 70  

                      case VK_LEFT:     
              #endif
4220   2                              MOtherSubItemLR(0);                break;
4221   2      
4222   2              // Exit item
4223   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
4224   2              case VK_ENTER:       
4225   2      #endif
4226   2      #if(_KEY_TYPE_OSD007 == _7KEY_SUPPORT)
4227   2              case VK_MENU:  
4228   2      #endif                  
4229   2              case VK_AUTO:
4230   2              case VK_IR_EXIT:
4231   2                  CExitToMainItem(MENU_MAIN_OTHER);  break;
4232   2              // Other key
4233   2              default:             COthterKeyAction();                break;
4234   2          }
4235   1      }
4236          
4237          //----------------------------------------------------------------------------------------------------
4238          void MOtherSubItemMenu(void)
4239          {
4240   1          CClearMsg(_CLEAR_MSG_ONLY);
4241   1          CSetItemWindowState(_SELECT_SUB_WINDOW, _SELECT_STATE);
4242   1      
4243   1          switch(ucOsdState)
4244   1          {
4245   2              case MENU_SUB_RESET:
4246   2                  DoReset();
4247   2                  if (_SOURCE_VGA == _GET_INPUT_SOURCE())
4248   2                  {
4249   3                     // CAutoDoWhiteBalance();
4250   3                      CAutoDoAutoConfig();
4251   3                  }
4252   2      
4253   2                  CSetItemWindowState(_SELECT_SUB_WINDOW, _MOVE_STATE);
4254   2                  ShowMode();
4255   2                  
4256   2                  
4257   2                  break;
4258   2      
4259   2      #if(_BLUE_BACKGROUND_FUNC == _ENABLE)
4260   2              case MENU_SUB_BLUE: 
4261   2                  CenterTextout((BYTE *)sOn_Off[_GET_BLUE_BACKGROUND()][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
4262   2                  ucOsdState = MENU_BLUE_ADJ;     
4263   2                  break;
4264   2      #endif
4265   2      
4266   2      #if(_AUTO_POWER_DOWN)
4267   2              case MENU_SUB_AUTO_POWER:
4268   2                  {
4269   3                      BYTE ucTemp = _GET_POWER_DOWN_TIME();
4270   3          
4271   3                      if (0 == ucTemp) // Auto power down time off
4272   3                         CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
4273   3                      else
4274   3                      {
4275   4                         Gotoxy(13, _MESSAGE_V_POSITION, BYTE_DISPLAY);
4276   4                         CShowNumber((ucTemp * 15), 0);    
4277   4                      }
4278   3                  }
4279   2                  ucOsdState = MENU_AUTO_POWER_DOWN_ADJ;     
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 71  

4280   2                  break;
4281   2      #endif
4282   2      
4283   2      #if(_IMAGE_COLOR_MODE)
4284   2              case MENU_SUB_COLOR_MODE: 
4285   2                  CDrawColorModeState(_GET_IMAGE_COLOR_MODE());
4286   2                  ucOsdState = MENU_COLOR_MODE_ADJ;     
4287   2                  break;
4288   2      #endif
4289   2      
4290   2      #if(_SHARPNESS_ADJ)
                      case MENU_SUB_SHARP:
                          Gotoxy(13, _MESSAGE_V_POSITION, BYTE_DISPLAY);
              #if(_VIDEO_SUPPORT)  // Source video
                          if (_GET_INPUT_SOURCE() != _SOURCE_VGA   && 
                              _GET_INPUT_SOURCE() != _SOURCE_DVI   && 
                              _GET_INPUT_SOURCE() != _SOURCE_YPBPR &&
                              _GET_INPUT_SOURCE() != _SOURCE_HDMI)
                              CShowNumber(_GET_VIDEO_SHARP(), 0);    
                          else
              #endif   
                          CShowNumber(GET_SHARPNESS(), 0);    
                          ucOsdState = MENU_SHARP_ADJ;
                          break;
              #endif
4305   2      
4306   2              case MENU_SUB_OTHER_CLOSE:
4307   2                  CExitToMainItem(MENU_MAIN_OTHER);
4308   2                  break;
4309   2          }
4310   1      }
4311          
4312          //----------------------------------------------------------------------------------------------------
4313          bit bOtherItemSupport(BYTE ucOSDItem)
4314          {
4315   1          switch(ucOSDItem)
4316   1          {
4317   2              case MENU_SUB_RESET:  
4318   2              case MENU_SUB_OTHER_CLOSE:
4319   2                  return 1;
4320   2      /*      for close blue adjust by chenlinfu 2007/09/28
4321   2      #if(_BLUE_BACKGROUND_FUNC == _ENABLE)
4322   2              case MENU_SUB_BLUE: 
4323   2                  return 1;
4324   2      #endif
4325   2      */
4326   2      #if(_AUTO_POWER_DOWN)
4327   2              case MENU_SUB_AUTO_POWER:
4328   2                  return 1;
4329   2      #endif
4330   2      
4331   2      #if(_IMAGE_COLOR_MODE)
4332   2              case MENU_SUB_COLOR_MODE:
4333   2                  return 1;
4334   2      #endif
4335   2      
4336   2      #if(_SHARPNESS_ADJ)
                      case MENU_SUB_SHARP:
                          return 1;
              #endif
4340   2          }
4341   1      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 72  

4342   1          return 0;
4343   1      }
4344          
4345          //----------------------------------------------------------------------------------------------------
4346          void MOtherSubItemLR(BYTE LR)
4347          {
4348   1          BYTE ucTemp  = 0;
4349   1          BYTE ucItem  = 0;
4350   1          
4351   1          // Search next item
4352   1          while(1)
4353   1          {
4354   2              ucOsdState = ValueInRangeChange(MENU_SUB_RESET, MENU_SUB_OTHER_CLOSE, ucOsdState, LR, 1);
4355   2      
4356   2              if (bOtherItemSupport(ucOsdState))
4357   2                  break; 
4358   2          }
4359   1      
4360   1          // Search item position
4361   1          ucTemp = MENU_SUB_RESET;
4362   1          while(1)
4363   1          {
4364   2              if (ucOsdState == ucTemp)
4365   2                 break;
4366   2      
4367   2              ucTemp = ValueInRangeChange(MENU_SUB_RESET, MENU_SUB_OTHER_CLOSE,ucTemp, 1, 1);
4368   2      
4369   2              if (bOtherItemSupport(ucTemp))
4370   2                 ucItem++;
4371   2      
4372   2          }
4373   1      
4374   1          CGotoNextSubItem(ucItem);
4375   1      }
4376          
4377          //--------- Color mode proc ----------------------------------
4378          #if(_IMAGE_COLOR_MODE)
4379          void MColorModeAdjProc(void)
4380          {             
4381   1          switch(ucKeyMessage)
4382   1          {
4383   2              // Move item
4384   2      #if(_USE_UD_LR_KEY_MSG)
4385   2              case VK_F_UP:
4386   2              case VK_F_DOWN:
4387   2                  MColorModeAdjMenu();
4388   2                  COsdProc();
4389   2                  break;
4390   2      #endif
4391   2      
4392   2              // Exit item
4393   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
4394   2              case VK_ENTER: 
4395   2      #endif
4396   2              case VK_AUTO:
4397   2              case VK_MENU:        MColorModeAdjMenu();       break;
4398   2      
4399   2              // Adjust
4400   2      #if(_USE_UD_LR_KEY_MSG)
4401   2              case VK_F_LEFT:
4402   2      #endif
4403   2              case VK_LEFT:        MColorModeAdjLR(1);        break;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 73  

4404   2      
4405   2              // Adjust
4406   2      #if(_USE_UD_LR_KEY_MSG)
4407   2              case VK_F_RIGHT:
4408   2      #endif
4409   2              case VK_RIGHT:       MColorModeAdjLR(0);        break;
4410   2                 
4411   2              // Other key
4412   2              default:             COthterKeyAction();        break;
4413   2          }
4414   1      }
4415          //----------------------------------------------------------------------------------------------------
4416          void MColorModeAdjMenu(void)
4417          {
4418   1          ucOsdState = MENU_SUB_COLOR_MODE;
4419   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
4420   1      }
4421          
4422          //----------------------------------------------------------------------------------------------------
4423          void MColorModeAdjLR(BYTE LR)
4424          {
4425   1          BYTE ucTemp = _GET_IMAGE_COLOR_MODE();
4426   1      
4427   1          ucTemp = ValueInRangeChange(0, 3, ucTemp, LR, 1);
4428   1          _SET_IMAGE_COLOR_MODE(ucTemp);
4429   1          CSetColorMode(ucTemp);
4430   1      
4431   1          CClearMsg(_CLEAR_MSG_ONLY);
4432   1          CDrawColorModeState(ucTemp);
4433   1         
4434   1          ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
4435   1      }
4436          
4437          //----------------------------------------------------------------------------------------------------
4438          void CDrawColorModeState(BYTE ucColorModeState)
4439          {
4440   1          BYTE ucPosH = 14;
4441   1          BYTE ucPosV = _MESSAGE_V_POSITION;
4442   1      
4443   1          if (MENU_IMAGE_ADJ == ucOsdState)
4444   1          {
4445   2              ucPosH = 0;
4446   2              ucPosV = 0;
4447   2              }
4448   1          switch(ucColorModeState)
4449   1          {
4450   2              case 0:  // Subdued
4451   2                  CenterTextout((BYTE *)sColorMode0[GET_LANGUAGE], ucPosH, ucPosV);
4452   2                  break;
4453   2      
4454   2              case 1:  // Lightful
4455   2                  CenterTextout((BYTE *)sColorMode1[GET_LANGUAGE], ucPosH, ucPosV);
4456   2                  break;
4457   2      
4458   2              case 2:  // Standard
4459   2                  CenterTextout((BYTE *)sColorMode2[GET_LANGUAGE], ucPosH, ucPosV);
4460   2                  break;
4461   2      
4462   2              case 3:  // User
4463   2                  CenterTextout((BYTE *)sColorMode3[GET_LANGUAGE], ucPosH, ucPosV);
4464   2                  break;
4465   2      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 74  

4466   2              case 4:
4467   2                  CenterTextout((BYTE *)sColorMode4[GET_LANGUAGE], ucPosH, ucPosV);
4468   2                  break;
4469   2      
4470   2              case 5:
4471   2                  CenterTextout((BYTE *)sColorMode5[GET_LANGUAGE], ucPosH, ucPosV);
4472   2                  break;
4473   2          }
4474   1      }
4475          
4476          //----------------------------------------------------------------------------------------------------
4477          void CSetColorMode(BYTE ucMode)
4478          {
4479   1          switch(ucMode)
4480   1          {
4481   2              case 0:
4482   2                  BRIGHTNESS_GUAGE = 45;
4483   2                  CONTRAST_GUAGE   = 55;
4484   2                  SATURATION_GUAGE = 60;
4485   2                  break;
4486   2      
4487   2              case 1:
4488   2                  BRIGHTNESS_GUAGE = 60;
4489   2                  CONTRAST_GUAGE   = 60;
4490   2                  SATURATION_GUAGE = 60;
4491   2                  break;
4492   2      
4493   2              case 2:
4494   2                  BRIGHTNESS_GUAGE = 50;
4495   2                  CONTRAST_GUAGE   = 50;
4496   2                  SATURATION_GUAGE = 50;
4497   2                  break;
4498   2      
4499   2              case 3:
4500   2                  CEepromLoadBriConData();
4501   2                  CEepromLoadVedioColor();
4502   2                  break;
4503   2      
4504   2              case 4:
4505   2                  break;
4506   2      
4507   2              case 5:
4508   2                  break;
4509   2          }
4510   1          CAdjustBrightness();
4511   1          CAdjustContrast();
4512   1          gmi_CAdjustVDCSaturation(stConBriData.Saturation);
4513   1      }
4514          void CGotoAdjImage(void)
4515          {                 
4516   1          COsdFxDisableOsd();
4517   1          SetOSDRamAddress(ROW_COUNT,COL_WIDTH,FONT_BASE_ADDRESS);
4518   1          SetRowCmds(ROW_COUNT,COL_WIDTH);
4519   1          COsdFxCodeWrite(ucCloseAllWindow);
4520   1          SetRowCmds(ROW_COUNT,COL_WIDTH);
4521   1      
4522   1           SetOSDDouble(0x03  | OSD_WINDOWCHAR_BLENDING);   
4523   1      
4524   1           if (_GET_OSD_SIZE()) 
4525   1              OSDPosition(_OSD_DOUBLE_WIDTH(220), _OSD_DOUBLE_HEIGHT(54), _LIFT_UP_H_OFFSET, 1, 0x03);
4526   1            else
4527   1             OSDPosition(220, 54, _LIFT_UP_H_OFFSET, 1, 0x03);
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 75  

4528   1      
4529   1          CClearWindow(0x20);
4530   1      
4531   1      #if(_AUTO_POWER_DOWN)
4532   1          bTimerOnScreen = 0;
4533   1      #endif
4534   1      
4535   1          ucOsdState = MENU_IMAGE_ADJ;
4536   1      
4537   1          CDrawColorModeState(_GET_IMAGE_COLOR_MODE());
4538   1      
4539   1          COsdFxEnableOsd();
4540   1      }
4541          //----------------------------------------------------------------------------------------------------
4542          void MImageAdj(void)
4543          {
4544   1          switch(ucKeyMessage)
4545   1          {
4546   2              case _IR_IMAGE_KEY_MESSAGE:
4547   2                  OSDClear(0, 1, 1, COL_WIDTH - 2, 0x00, BYTE_DISPLAY);
4548   2                  MColorModeAdjLR(1);
4549   2                  break;
4550   2      
4551   2              default:
4552   2                  COthterKeyAction();
4553   2                  break;
4554   2          }
4555   1      }
4556          //----------------------------------------------------------------------------------------------------
4557          
4558          #endif
4559          
4560          //--------- Sharp adj proc ----------------------------------
4561          #if(_SHARPNESS_ADJ)
              void MSharpAdjProc(void)
              {             
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MSharpAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_AUTO:
                      case VK_IR_EXIT:
                      case VK_MENU:        MSharpAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        
                                      MSharpAdjLR(1);        break;
              
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 76  

                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:  
                                      MSharpAdjLR(0);        break;
                         
                      // Other key
                      default:             COthterKeyAction();    break;
                  }
              }
              //----------------------------------------------------------------------------------------------------
              void MSharpAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_SHARP;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
              }
              
              //----------------------------------------------------------------------------------------------------
              void MSharpAdjLR(BYTE LR)
              {
                  BYTE ucTemp = GET_SHARPNESS(); // Default to VGA sharpness
                  BYTE ucMax  = 4;
              
              #if(_VIDEO_SUPPORT)  // Source video
                  if (_GET_INPUT_SOURCE() != _SOURCE_VGA  && 
                      _GET_INPUT_SOURCE() != _SOURCE_DVI  && 
                      _GET_INPUT_SOURCE() != _SOURCE_HDMI && 
                      _GET_INPUT_SOURCE() != _SOURCE_YPBPR)
                  {
                      ucTemp = _GET_VIDEO_SHARP();
                      ucMax  = 63;
                  }
              else
              #endif   
                  {
                      ucTemp = GET_SHARPNESS();
                      ucMax  = 4;
                  }
              if(ucTemp>ucMax)
                      ucTemp=ucMax;
                  ucTemp = ValueInRangeChange(0, ucMax, ucTemp, LR, 0);
              
                  CClearMsg(_CLEAR_MSG_ONLY);
              
                  Gotoxy(13, _MESSAGE_V_POSITION, BYTE_DISPLAY);
              #if(_VIDEO_SUPPORT)  // Source video
                  if (_GET_INPUT_SOURCE() != _SOURCE_VGA  && 
                      _GET_INPUT_SOURCE() != _SOURCE_DVI  && 
                      _GET_INPUT_SOURCE() != _SOURCE_HDMI && 
                      _GET_INPUT_SOURCE() != _SOURCE_YPBPR)
                  {
                      _SET_VIDEO_SHARP(ucTemp);
                      CShowNumber(_GET_VIDEO_SHARP(), 0);    
                      CAdjustVideoSharp();
                      ucOsdEventMsg = _SAVE_EE_VEDIOCOLOR_MSG;
                  }
                  else
              #endif
                  {   // VGA/DVI/HDMI/YPBPR sharpness
                      SET_SHARPNESS(ucTemp);
                      CShowNumber(GET_SHARPNESS(), 0); 
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 77  

                      CAdjustSharpness();
                      ucOsdEventMsg = _SAVE_EE_SYSTEMDATA_MSG;  
                  }
                 
              }
              
              #endif
4659          
4660          //----------------------------------------------------------------------------------------------------
4661          #if(_IR_ENABLE)        
4662          void DrawMuteState(void)
4663          {
4664   1          COsdFxDisableOsd();
4665   1          SetOSDRamAddress(ROW_COUNT,COL_WIDTH,FONT_BASE_ADDRESS);
4666   1          SetRowCmds(ROW_COUNT,COL_WIDTH);
4667   1          COsdFxCodeWrite(ucCloseAllWindow);
4668   1          CClearWindow(0x20);
4669   1      
4670   1          SetOSDDouble(OSD_DOUBLE_WIDTH_ENABLE| OSD_DOUBLE_HEIGHT_ENABLE);   
4671   1           //if (_GET_OSD_SIZE()) 
4672   1            //  OSDPosition(_OSD_DOUBLE_WIDTH(55), _OSD_DOUBLE_HEIGHT(30), _RIGHT_UP_OSD_H_OFFSET, 1, 0x03);
4673   1            //else
4674   1             OSDPosition(55, 30, _RIGHT_UP_OSD_H_OFFSET, 1, 0x03);
4675   1      
4676   1      
4677   1      #if(_AUTO_POWER_DOWN)
4678   1          bTimerOnScreen = 0;
4679   1      #endif
4680   1      
4681   1          if (GET_MUTE_STATE() == STATE_MUTEON)
4682   1          {
4683   2      #if(_HARDWARE_LOAD_FONT == _ON)
              
                      CScalerLoadHardwareVLCFont(tFntIconMute, 0x10);
              
              #else
4688   2      
4689   2              CScalerLoadFont(tFntIconMute, 0x10, 6, _COMPRESS_FONT);
4690   2      
4691   2      #endif
4692   2              CTimerCancelTimerEvent(COsdDispOsdTimerEvent);
4693   2              ucOsdState = MENU_SHOW_MUTE_STATE;
4694   2          }
4695   1          else
4696   1          {
4697   2      #if(_HARDWARE_LOAD_FONT == _ON)
              
                      CScalerLoadHardwareVLCFont(tFntIconSpker, 0x10);
              
              #else
4702   2      
4703   2              CScalerLoadFont(tFntIconSpker, 0x10, 6, _COMPRESS_FONT);
4704   2      
4705   2      #endif
4706   2              ucOsdState = MENU_SHOW_MSG_STATE;
4707   2              CTimerReactiveTimerEvent(SEC(5),COsdDispOsdTimerEvent);
4708   2          }
4709   1      
4710   1          DispIcon(1,0,0x10);   
4711   1      
4712   1          COsdFxEnableOsd();
4713   1      }
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 78  

4714          #endif
4715          
4716          
4717          //--------- brightness proc ----------------------------------
4718          void MBrightAdjProc(void)
4719          {
4720   1          switch(ucKeyMessage)
4721   1          {
4722   2              // Move item
4723   2      #if(_USE_UD_LR_KEY_MSG)
4724   2              case VK_F_UP:
4725   2              case VK_F_DOWN:
4726   2                  MBrightAdjMenu();
4727   2                  COsdProc();
4728   2                  break;
4729   2      #endif
4730   2      
4731   2              // Exit item
4732   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
4733   2              case VK_ENTER: 
4734   2      #endif
4735   2              case VK_AUTO:
4736   2              case VK_IR_EXIT:
4737   2              case VK_MENU:        MBrightAdjMenu();       break;
4738   2      
4739   2              // Adjust
4740   2      #if(_USE_UD_LR_KEY_MSG)
4741   2              case VK_F_LEFT:
4742   2      #endif
4743   2              case VK_LEFT:        MBrightAdjLR(1);        break;
4744   2      
4745   2              // Adjust
4746   2      #if(_USE_UD_LR_KEY_MSG)
4747   2              case VK_F_RIGHT:
4748   2      #endif
4749   2              case VK_RIGHT:       MBrightAdjLR(0);        break;
4750   2                  
4751   2              // Other key
4752   2              default:             COthterKeyAction();     break;
4753   2          }
4754   1      }
4755          
4756          //----------------------------------------------------------------------------------------------------
4757          void MBrightAdjMenu(void)
4758          {
4759   1          ucOsdState = MENU_ITEM_BRIGHT;
4760   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
4761   1      }
4762          
4763          //----------------------------------------------------------------------------------------------------
4764          void MBrightAdjLR(BYTE  LR)
4765          {   
4766   1          SET_KEYREPEATENABLE();
4767   1          BRIGHTNESS_GUAGE = ValueInRangeChange(0, 100, BRIGHTNESS_GUAGE, LR, 0);
4768   1          SLIDER1(BRIGHTNESS_GUAGE);
4769   1          CAdjustBrightness();
4770   1          
4771   1          stSystemData.BackLight = BRIGHTNESS_GUAGE;
4772   1          CAdjustBacklight();
4773   1          CEepromSaveSystemData();
4774   1          ucOsdEventMsg = _SAVE_EE_BriConHueSat_MSG;                       
4775   1      }
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 79  

4776          
4777          
4778          //--------- CONTRAST ADJUST PROC ----------------------------------
4779          void MContrastAdjProc(void)
4780          {
4781   1          switch(ucKeyMessage)
4782   1          {
4783   2              // Move item
4784   2      #if(_USE_UD_LR_KEY_MSG)
4785   2              case VK_F_UP:
4786   2              case VK_F_DOWN:
4787   2                  MContrastAdjMenu();
4788   2                  COsdProc();
4789   2                  break;
4790   2      #endif
4791   2      
4792   2              // Exit item
4793   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
4794   2              case VK_ENTER: 
4795   2      #endif
4796   2              case VK_AUTO:
4797   2               case VK_IR_EXIT:
4798   2              case VK_MENU:        MContrastAdjMenu();       break;
4799   2      
4800   2              // Adjust
4801   2      #if(_USE_UD_LR_KEY_MSG)
4802   2              case VK_F_LEFT:
4803   2      #endif
4804   2              case VK_LEFT:        MContrastAdjLR(1);        break;
4805   2      
4806   2              // Adjust
4807   2      #if(_USE_UD_LR_KEY_MSG)
4808   2              case VK_F_RIGHT:
4809   2      #endif
4810   2              case VK_RIGHT:       MContrastAdjLR(0);        break;
4811   2      
4812   2              // Other key
4813   2              default:             COthterKeyAction();       break;
4814   2          }
4815   1      }
4816          
4817          //----------------------------------------------------------------------------------------------------
4818          void MContrastAdjMenu(void)
4819          {
4820   1          ucOsdState = MENU_ITEM_CONTRAST;
4821   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
4822   1      }
4823          
4824          //----------------------------------------------------------------------------------------------------
4825          void MContrastAdjLR(BYTE  LR)
4826          {   
4827   1          SET_KEYREPEATENABLE();
4828   1          CONTRAST_GUAGE = ValueInRangeChange(0, 100, CONTRAST_GUAGE, LR, 0);
4829   1          SLIDER1(CONTRAST_GUAGE);
4830   1          CAdjustContrast();
4831   1          ucOsdEventMsg = _SAVE_EE_BriConHueSat_MSG;     
4832   1      }
4833          
4834          //--------- LANGUAGE ADJUST PROC ----------------------------------
4835          void MLanguageAdjProc(void)
4836          {
4837   1          switch(ucKeyMessage)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 80  

4838   1          {
4839   2              // Move item
4840   2      #if(_USE_UD_LR_KEY_MSG)
4841   2              case VK_F_UP:
4842   2              case VK_F_DOWN:
4843   2                  MLanguageAdjMenu();
4844   2                  COsdProc();
4845   2                  break;
4846   2      #endif
4847   2      
4848   2              // Exit item
4849   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
4850   2              case VK_ENTER: 
4851   2      #endif
4852   2              case VK_AUTO:
4853   2              case VK_IR_EXIT:
4854   2              case VK_MENU:        MLanguageAdjMenu();       break;
4855   2      
4856   2              // Adjust
4857   2      #if(_USE_UD_LR_KEY_MSG)
4858   2              case VK_F_LEFT:
4859   2      #endif
4860   2              case VK_LEFT:        MLanguageAdjLR(1);        break;
4861   2      
4862   2              // Adjust
4863   2      #if(_USE_UD_LR_KEY_MSG)
4864   2              case VK_F_RIGHT:
4865   2      #endif
4866   2              case VK_RIGHT:       MLanguageAdjLR(0);        break;
4867   2                  
4868   2              // Other key
4869   2              default:             COthterKeyAction();       break;
4870   2          }
4871   1      }
4872          
4873          //----------------------------------------------------------------------------------------------------
4874          void MLanguageAdjMenu(void)
4875          {
4876   1          ucOsdState = MENU_SUB_LANGUAGE;
4877   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);        
4878   1      }
4879          
4880          //----------------------------------------------------------------------------------------------------
4881          void MLanguageAdjLR(BYTE  LR)
4882          {
4883   1          BYTE ucLng = GET_LANGUAGE;
4884   1          
4885   1          if (LR) 
4886   1              ucLng = GetNextLanguage(ucLng);
4887   1          else   
4888   1              ucLng = GetPrevLanguage(ucLng);
4889   1          
4890   1          SET_LANGUAGE(ucLng);
4891   1          // Redraw
4892   1          CClearSubItem();
4893   1          CClearMsg(_CLEAR_MSG_ONLY);
4894   1          
4895   1          // Load Font
4896   1          LoadLanguageFont();
4897   1          CDrawOSDFuncPage();
4898   1          CenterTextout((BYTE *)sLangName[GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
4899   1          ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 81  

4900   1      }
4901          #if(_DISPLAY_SIZE_ADJ)
4902           //--------- 16:9-4:3 PROC ----------------------------------
4903          void MDispModeAdjProc(void)
4904          {
4905   1          switch(ucKeyMessage)
4906   1          {
4907   2              // Move item
4908   2      #if(_USE_UD_LR_KEY_MSG)
4909   2              case VK_F_UP:
4910   2              case VK_F_DOWN:
4911   2                  MDispModeAdjMenu();
4912   2                  COsdProc();
4913   2                  break;
4914   2      #endif
4915   2      
4916   2              // Exit item
4917   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
4918   2              case VK_ENTER: 
4919   2      #endif
4920   2              case VK_IR_EXIT:
4921   2              case VK_MENU:        MDispModeAdjMenu();       break;
4922   2      
4923   2              // Adjust
4924   2      #if(_USE_UD_LR_KEY_MSG)
4925   2              case VK_F_LEFT:
4926   2      #endif
4927   2              case VK_LEFT:        MDispModeAdjLR(1);        break;
4928   2      
4929   2              // Adjust
4930   2      #if(_USE_UD_LR_KEY_MSG)
4931   2              case VK_F_RIGHT:
4932   2      #endif
4933   2              case VK_RIGHT:       MDispModeAdjLR(0);        break;
4934   2      
4935   2              // Other key
4936   2              default:             COthterKeyAction();   break;
4937   2          }
4938   1      }
4939          
4940          //----------------------------------------------------------------------------------------------------
4941          void MDispModeAdjMenu(void)
4942          {
4943   1          ucOsdState = MENU_SUB_DISMODE;
4944   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
4945   1      }
4946          
4947          //----------------------------------------------------------------------------------------------------
4948          void MDispModeAdjLR(BYTE LR)
4949          {   
4950   1              LR =LR;
4951   1          CClearMsg(_CLEAR_AND_SELECT_SUB_ITEM);
4952   1              if(_GET_INPUT_SOURCE()==_SOURCE_VIDEO_TV)
4953   1                 gmi_CI2CWrite9886(ucTVType, _TUNER_MUTE_ON, _NORMAL_MODE);
4954   1      
4955   1         if(_GET_DISPLAY_MODE()== DISPLAY_MODE_16_10)
4956   1          _SET_DISPLAY_MODE(DISPLAY_MODE_43);
4957   1         else    
4958   1          _SET_DISPLAY_MODE(DISPLAY_MODE_16_10);
4959   1              CEepromSaveOsdUserData();
4960   1              bVideoON = 0;
4961   1              ucVideoNoModeTime = 252;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 82  

4962   1              CModeResetMode();   
4963   1              if(_GET_INPUT_SOURCE()==_SOURCE_VIDEO_TV)
4964   1                 gmi_CI2CWrite9886(ucTVType, _TUNER_MUTE_OFF, _NORMAL_MODE);
4965   1            CenterTextout((BYTE *)sDisp_mode[_GET_DISPLAY_MODE()], 14, _MESSAGE_V_POSITION);
4966   1        //   ucChangeSourceCount = 1;
4967   1       //   ucOsdEventMsg       = _DO_SHOW_NOTE;
4968   1      //    ucCurrState         = _SOURCE_CHANGE_STATE;
4969   1          #if(_IR_ENABLE)
4970   1           ucDetectIR_Cmd = 0;
4971   1          #endif
4972   1               MUTE_ON();
4973   1      #if(_CHANGE_SOURCE_BACKGROUCD_COLOR==_BACK_COLOR)                                               
4974   1                      CAdjustBackgroundColor(0x00, 0x00, 0x00);     
4975   1      #else
                              CAdjustBackgroundColor(0x00, 0x00, 0xFF);     
              #endif
4978   1                      CScalerSetBit(_VDISP_CTRL_28, ~(_BIT5), _BIT5);
4979   1                      COsdFxDisableOsd();
4980   1      }
4981          
4982          #endif
4983          //--------- Volume adjust proc ----------------------------------
4984          void MVolumeAdjProc()
4985          {
4986   1          switch(ucKeyMessage)
4987   1          {
4988   2              // Move item
4989   2      #if(_USE_UD_LR_KEY_MSG)
4990   2              case VK_F_UP:
4991   2              case VK_F_DOWN:
4992   2                  MVolumeAdjMenu();
4993   2                  if (ucOsdState == MENU_SUB_VOLUME)
4994   2                     COsdProc();
4995   2                  break;
4996   2      #endif
4997   2      
4998   2              // Exit item
4999   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
5000   2              case VK_ENTER: 
5001   2      #endif
5002   2              case VK_AUTO:
5003   2              case VK_IR_EXIT:
5004   2              case VK_MENU:        MVolumeAdjMenu();       break;
5005   2      
5006   2              // Adjust
5007   2      #if(_USE_UD_LR_KEY_MSG)
5008   2              case VK_F_LEFT:
5009   2      #endif
5010   2      #if(_IR_ENABLE)
5011   2              case VK_IR_VOLINC:
5012   2      #endif
5013   2              case VK_LEFT:        MVolumeAdjLR(1);        break;
5014   2      
5015   2              // Adjust
5016   2      #if(_USE_UD_LR_KEY_MSG)
5017   2              case VK_F_RIGHT:
5018   2      #endif
5019   2      #if(_IR_ENABLE)
5020   2              case VK_IR_VOLDEC:
5021   2      #endif
5022   2              case VK_RIGHT:       MVolumeAdjLR(0);        break;
5023   2                  
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 83  

5024   2              // Other key
5025   2              default:             COthterKeyAction();     break;
5026   2          }
5027   1      }
5028          
5029          //----------------------------------------------------------------------------------------------------
5030          void MVolumeAdjMenu(void)
5031          {
5032   1          if (MENU_VOLUME_SP == ucOsdState)
5033   1          {
5034   2              COsdFxDisableOsd();
5035   2              CTimerDelayXms(100);
5036   2      #if(_IR_ENABLE)        
5037   2              ucDetectIR_Cmd = 0;
5038   2      #endif
5039   2          }
5040   1          else
5041   1          {
5042   2              ucOsdState = MENU_SUB_VOLUME;
5043   2              CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);        
5044   2          }
5045   1      }
5046          
5047          //----------------------------------------------------------------------------------------------------
5048          void MVolumeAdjLR(BYTE  LR)
5049          {
5050   1          SET_MUTE_STATE(STATE_MUTEOFF);
5051   1          SET_KEYREPEATENABLE();
5052   1          stOsdUserData.Volume = ValueInRangeChange(0,100,stOsdUserData.Volume,LR,0);
5053   1      
5054   1          if (MENU_VOLUME_SP == ucOsdState)
5055   1             OSDSlider(3, 1, 10, stOsdUserData.Volume, 100, 0x40, _SHOW_PERCENT);
5056   1          else
5057   1             SLIDER1(stOsdUserData.Volume);
5058   1          CSetVolume();
5059   1          ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
5060   1              //add by chenlinfu 2007/10/18
5061   1              CTimerReactiveTimerEvent(SEC(stOsdUserData.OsdTimeout),COsdDispOsdTimerEvent);
5062   1      }
5063          
5064          //--------- Mute PROC ----------------------------------
5065          void MMuteAdjProc(void)
5066          {
5067   1          switch(ucKeyMessage)
5068   1          {
5069   2              // Move item
5070   2      #if(_USE_UD_LR_KEY_MSG)
5071   2              case VK_F_UP:
5072   2              case VK_F_DOWN:
5073   2                  MMuteAdjMenu();
5074   2                  COsdProc();
5075   2                  break;
5076   2      #endif
5077   2      
5078   2              // Exit item
5079   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
5080   2              case VK_ENTER: 
5081   2      #endif
5082   2              case VK_AUTO:
5083   2               case VK_IR_EXIT:
5084   2              case VK_MENU:        MMuteAdjMenu();       break;
5085   2      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 84  

5086   2              // Adjust
5087   2      #if(_USE_UD_LR_KEY_MSG)
5088   2              case VK_F_LEFT:
5089   2      #endif
5090   2              case VK_LEFT:        MMuteAdjLR(1);        break;
5091   2      
5092   2              // Adjust
5093   2      #if(_USE_UD_LR_KEY_MSG)
5094   2              case VK_F_RIGHT:
5095   2      #endif
5096   2              case VK_RIGHT:       MMuteAdjLR(0);        break;
5097   2      
5098   2              // Other key
5099   2              default:             COthterKeyAction();   break;
5100   2          }
5101   1      }
5102          
5103          //----------------------------------------------------------------------------------------------------
5104          void MMuteAdjMenu(void)
5105          {
5106   1          ucOsdState = MENU_SUB_MUTE;
5107   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
5108   1      }
5109          
5110          //----------------------------------------------------------------------------------------------------
5111          void MMuteAdjLR(BYTE LR)
5112          {   
5113   1          CClearMsg(_CLEAR_MSG_ONLY);
5114   1      
5115   1          LR = GET_MUTE_STATE();
5116   1          
5117   1          LR = 1 - LR;
5118   1          
5119   1          SET_MUTE_STATE(LR);
5120   1          CSetVolume();   
5121   1          CenterTextout((BYTE *)sOn_Off[LR][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
5122   1          ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
5123   1      }
5124          
5125          #if(_SOUND_PROCESSOR == _ENABLE)
              //--------- Balance adjust proc ----------------------------------
              void MBalanceAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MBalanceAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_IR_EXIT:
                      case VK_MENU:        MBalanceAdjMenu();       break;
              
                      // Adjust
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 85  

              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MBalanceAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MBalanceAdjLR(0);        break;
                          
                      // Other key
                      default:             COthterKeyAction();      break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MBalanceAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_BALANCE;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);        
              }
              
              //----------------------------------------------------------------------------------------------------
              void MBalanceAdjLR(BYTE  LR)
              {
                  SET_KEYREPEATENABLE();
                  stOsdUserData.Balance = ValueInRangeChange(0,100,stOsdUserData.Balance,LR,0);
                  SLIDER1(stOsdUserData.Balance);
                  CSetVolume();
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              //--------- Bass adjust proc ----------------------------------
              void MBassAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MBassAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_IR_EXIT:
                      case VK_MENU:        MBassAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MBassAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 86  

                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MBassAdjLR(0);        break;
              
                      // Other key
                      default:             COthterKeyAction();   break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MBassAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_BASS;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);        
              }
              
              //----------------------------------------------------------------------------------------------------
              void MBassAdjLR(BYTE  LR)
              {
                  SET_KEYREPEATENABLE();
                  stOsdUserData.Bass = ValueInRangeChange(0,100,stOsdUserData.Bass,LR,0);
                  SLIDER1(stOsdUserData.Bass);
                  CSetVolume();
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              
              //--------- Treble adjust proc ----------------------------------
              void MTrebleAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MTrebleAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_IR_EXIT:
                      case VK_MENU:        MTrebleAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MTrebleAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MTrebleAdjLR(0);        break;
              
                      // Other key
                      default:             COthterKeyAction();     break;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 87  

                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MTrebleAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_TREBLE;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);        
              }
              
              //----------------------------------------------------------------------------------------------------
              void MTrebleAdjLR(BYTE  LR)
              {
                  SET_KEYREPEATENABLE();
                  stOsdUserData.Treble = ValueInRangeChange(0,100,stOsdUserData.Treble,LR,0);
                  SLIDER1(stOsdUserData.Treble);
                  CSetVolume();
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              //--------- SRS adjust proc ----------------------------------
              void MSRSAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MSRSAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                      case VK_IR_EXIT:
                      case VK_MENU:        MSRSAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MSRSAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MSRSAdjLR(0);        break;
              
                      // Other key
                      default:             COthterKeyAction();  break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MSRSAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_SRS;
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 88  

                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);        
              }
              
              //----------------------------------------------------------------------------------------------------
              void MSRSAdjLR(BYTE  LR)
              {
                  SET_KEYREPEATENABLE();
                  stOsdUserData.SRS = ValueInRangeChange(0,100,stOsdUserData.SRS,LR,0);
                  SLIDER1(stOsdUserData.SRS);
                  CSetVolume();
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              //--------- BBE adjust proc ----------------------------------
              void MBBEAdjProc(void)
              {
                  switch(ucKeyMessage)
                  {
                      // Move item
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_UP:
                      case VK_F_DOWN:
                          MBBEAdjMenu();
                          COsdProc();
                          break;
              #endif
              
                      // Exit item
              #if(_MENU_FUNC == _MENU_EXIT_ITEM)
                      case VK_ENTER: 
              #endif
                       case VK_IR_EXIT:
                      case VK_MENU:        MBBEAdjMenu();       break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_LEFT:
              #endif
                      case VK_LEFT:        MBBEAdjLR(1);        break;
              
                      // Adjust
              #if(_USE_UD_LR_KEY_MSG)
                      case VK_F_RIGHT:
              #endif
                      case VK_RIGHT:       MBBEAdjLR(0);        break;
              
                      // Other key
                      default:             COthterKeyAction();  break;
                  }
              }
              
              //----------------------------------------------------------------------------------------------------
              void MBBEAdjMenu(void)
              {
                  ucOsdState = MENU_SUB_BBE;
                  CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);        
              }
              
              //----------------------------------------------------------------------------------------------------
              void MBBEAdjLR(BYTE  LR)
              {
                  SET_KEYREPEATENABLE();
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 89  

                  stOsdUserData.BBE = ValueInRangeChange(0,100,stOsdUserData.BBE,LR,0);
                  SLIDER1(stOsdUserData.BBE);
                  CSetVolume();
                  ucOsdEventMsg = _SAVE_EE_OSDUSERDATA_MSG;
              }
              
              #endif
5403          
5404          
5405          
5406          #if(_AUTO_POWER_DOWN)
5407          void CGotoAdjSleep(void)
5408          {    
5409   1              BYTE i; 
5410   1          //CInitOSDMainFrame();
5411   1          //SetOSDDouble(OSD_DOUBLE_HEIGHT_ENABLE | OSD_DOUBLE_WIDTH_ENABLE);
5412   1      
5413   1          COsdFxDisableOsd();
5414   1          SetOSDRamAddress(ROW_COUNT,COL_WIDTH,FONT_BASE_ADDRESS);
5415   1          //SetOSDDouble(OSD_DOUBLE_HEIGHT_ENABLE | OSD_DOUBLE_WIDTH_ENABLE);
5416   1          SetRowCmds(ROW_COUNT,COL_WIDTH);
5417   1          COsdFxCodeWrite(ucCloseAllWindow);
5418   1              CClearWindow(0x20);
5419   1           if (_GET_OSD_SIZE()) 
5420   1              OSDPosition(_OSD_DOUBLE_WIDTH(220), _OSD_DOUBLE_HEIGHT(54), _LIFT_UP_H_OFFSET, 1, 0x03);
5421   1            else
5422   1             OSDPosition(220, 54, _LIFT_UP_H_OFFSET, 1, 0x03);
5423   1              SetOSDDouble(0x03 | OSD_WINDOWCHAR_BLENDING);   
5424   1              DirectWOSDRam(0x00, 0x03, THE_BYTE0, 0x80|0x03);  // Row 0~2 character double height and width
5425   1      
5426   1          ucOsdState = SLEEP_TIME_ADJ;
5427   1          CenterTextout(sSLEEP_TIME, 7, 0);
5428   1      if(_GET_POWER_DOWN_TIME()!=0)
5429   1      {                // Clear item character
5430   2      
5431   2      
5432   2              //reset char width to 12 pixel
5433   2              Gotoxy(13, 0, BYTE_ATTRIB);
5434   2              CScalerSendAddr(_OSD_DATA_PORT_92, _WRITE, _NON_AUTOINC);
5435   2              for(i=0;i<3;i++)        
5436   2              CScalerSendByte(0x8c);
5437   2              CScalerSendWriteStop();
5438   2              
5439   2              Gotoxy(13, 0, BYTE_DISPLAY);
5440   2          CShowNumber((_GET_POWER_DOWN_TIME()*15),0);
5441   2      }
5442   1      else
5443   1              CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, 0);
5444   1      
5445   1          COsdFxEnableOsd();
5446   1      }
5447          //----------------------------------------------------------------------------------------------------
5448          void MSleepTimeAdj(void)
5449          {
5450   1          switch(ucKeyMessage)
5451   1          {  
5452   2              case VK_IR_SLEEP:
5453   2                  OSDClear(0, 15, 1, COL_WIDTH, 0x00, BYTE_DISPLAY);
5454   2                  MAutoPowerDownAdjLR(1);
5455   2                  break;
5456   2      
5457   2              default:
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 90  

5458   2                  COthterKeyAction();
5459   2                  break;
5460   2              }
5461   1      }
5462          //--------- AutoPowerDown PROC ----------------------------------
5463          void MAutoPowerDownAdjProc(void)
5464          {
5465   1          switch(ucKeyMessage)
5466   1          {
5467   2              // Move item
5468   2      #if(_USE_UD_LR_KEY_MSG)
5469   2              case VK_F_UP:
5470   2              case VK_F_DOWN:
5471   2                  MAutoPowerDownAdjMenu();
5472   2                  COsdProc();
5473   2                  break;
5474   2      #endif
5475   2      
5476   2              // Exit item
5477   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
5478   2              case VK_ENTER: 
5479   2      #endif
5480   2              case VK_AUTO:
5481   2              case VK_IR_EXIT:
5482   2              case VK_MENU:        MAutoPowerDownAdjMenu();       break;
5483   2      
5484   2              // Adjust
5485   2      #if(_USE_UD_LR_KEY_MSG)
5486   2              case VK_F_LEFT:
5487   2      #endif
5488   2              case VK_LEFT:        MAutoPowerDownAdjLR(1);        break;
5489   2      
5490   2              // Adjust
5491   2      #if(_USE_UD_LR_KEY_MSG)
5492   2              case VK_F_RIGHT:
5493   2      #endif
5494   2              case VK_RIGHT:       MAutoPowerDownAdjLR(0);        break;
5495   2      
5496   2              // Other key
5497   2              default:             COthterKeyAction();            break;
5498   2          }
5499   1      }
5500          
5501          //----------------------------------------------------------------------------------------------------
5502          void MAutoPowerDownAdjMenu(void)
5503          {
5504   1          ucOsdState = MENU_SUB_AUTO_POWER;
5505   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
5506   1      }
5507          
5508          //----------------------------------------------------------------------------------------------------
5509          void MAutoPowerDownAdjLR(BYTE LR)
5510          {
5511   1          BYTE i,ucTemp = _GET_POWER_DOWN_TIME();
5512   1              BYTE ucXPos=13;
5513   1              BYTE ucYPos = _MESSAGE_V_POSITION;
5514   1              
5515   1              if(ucOsdState == SLEEP_TIME_ADJ)
5516   1              {
5517   2                      ucXPos=13;
5518   2                      ucYPos =0;
5519   2      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 91  

5520   2              //reset char width to 12 pixel
5521   2              Gotoxy(13, 0, BYTE_ATTRIB);
5522   2              CScalerSendAddr(_OSD_DATA_PORT_92, _WRITE, _NON_AUTOINC);
5523   2              for(i=0;i<3;i++)        
5524   2              CScalerSendByte(0x8c);
5525   2              CScalerSendWriteStop();
5526   2              }
5527   1          
5528   1          CClearMsg(_CLEAR_MSG_ONLY);
5529   1      
5530   1          ucTemp = ValueInRangeChange(0,4,ucTemp,LR,1);
5531   1          
5532   1          _SET_POWER_DOWN_TIME(ucTemp);
5533   1          CEepromSaveSystemData(); // Save Adjust result
5534   1          
5535   1          ucAutoPowerDownTime = ucTemp * 15;
5536   1          if (0 == ucAutoPowerDownTime) // Auto power down time off
5537   1          {
5538   2              ucAutoPowerDownTime = 0xff;
5539   2          }
5540   1          
5541   1          ucMinuteCount       = 0;  // Reset count
5542   1          
5543   1              if(ucOsdState == SLEEP_TIME_ADJ)
5544   1      
5545   1                      {
5546   2                              CenterTextout(sSLEEP_TIME, 7, 0);
5547   2                          if (0 == _GET_POWER_DOWN_TIME() ) // Auto power down time off
5548   2                             CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, 0);//_MESSAGE_V_POSITION);
5549   2                          else
5550   2                          {
5551   3                             Gotoxy(13, 0, BYTE_DISPLAY);
5552   3                             CShowNumber((_GET_POWER_DOWN_TIME()  * 15), 0);    
5553   3                          }
5554   2                      }
5555   1              else
5556   1                      {
5557   2                          if (0 == _GET_POWER_DOWN_TIME() ) // Auto power down time off
5558   2                             CenterTextout((BYTE *)sOn_Off[0][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);//_MESSAGE_V_POSITION);
5559   2                          else
5560   2                          {
5561   3                             Gotoxy(13, _MESSAGE_V_POSITION, BYTE_DISPLAY);
5562   3                             CShowNumber((_GET_POWER_DOWN_TIME() * 15), 0);    
5563   3                          }
5564   2                      }
5565   1          LR = 0;
5566   1      }
5567          
5568          #endif
5569          
5570          #if(_BLUE_BACKGROUND_FUNC == _ENABLE)
5571          //--------- Blue proc ----------------------------------
5572          void MBlueAdjProc(void)
5573          {
5574   1          switch(ucKeyMessage)
5575   1          {
5576   2              // Move item
5577   2      #if(_USE_UD_LR_KEY_MSG)
5578   2              case VK_F_UP:
5579   2              case VK_F_DOWN:
5580   2                  MBlueAdjMenu();
5581   2                  COsdProc();
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 92  

5582   2                  break;
5583   2      #endif
5584   2      
5585   2              // Exit item
5586   2      #if(_MENU_FUNC == _MENU_EXIT_ITEM)
5587   2              case VK_ENTER: 
5588   2      #endif
5589   2              case VK_AUTO:
5590   2              case VK_IR_EXIT:
5591   2              case VK_MENU:        MBlueAdjMenu();       break;
5592   2      
5593   2              // Adjust
5594   2      #if(_USE_UD_LR_KEY_MSG)
5595   2              case VK_F_LEFT:
5596   2      #endif
5597   2              case VK_LEFT:        MBlueAdjLR(1);        break;
5598   2      
5599   2              // Adjust
5600   2      #if(_USE_UD_LR_KEY_MSG)
5601   2              case VK_F_RIGHT:
5602   2      #endif
5603   2              case VK_RIGHT:       MBlueAdjLR(0);        break;
5604   2      
5605   2              // Other key
5606   2              default:             COthterKeyAction();   break;
5607   2          }
5608   1      }
5609          
5610          //----------------------------------------------------------------------------------------------------
5611          void MBlueAdjMenu(void)
5612          {
5613   1          ucOsdState = MENU_SUB_BLUE;
5614   1          CClearMsg(_CLEAR_AND_EXIT_SUB_ITEM);
5615   1      }
5616          
5617          //----------------------------------------------------------------------------------------------------
5618          void MBlueAdjLR(BYTE LR)
5619          {   
5620   1               LR = LR;
5621   1          CClearMsg(_CLEAR_MSG_ONLY);
5622   1      
5623   1               if( _GET_BLUE_BACKGROUND())
5624   1                      {
5625   2                     _SET_BLUE_BACKGROUND(0);
5626   2                       LR= 0;
5627   2                      }
5628   1              else
5629   1                      {
5630   2                   _SET_BLUE_BACKGROUND(1);
5631   2                       LR= 1;
5632   2                      }
5633   1                      CAdjustBackgroundColor(0x00, 0x00, (_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV) ? ((_GET_BLUE
             -_BACKGROUND()) ? 0xFF: 0x00) : 0x00);
5634   1         
5635   1          CEepromSaveSystemData(); // Save Adjust result
5636   1          CenterTextout((BYTE *)sOn_Off[LR][GET_LANGUAGE], 14, _MESSAGE_V_POSITION);
5637   1      }
5638          
5639          //----------------------------------------------------------------------------------------------------
5640          #endif
5641          
5642          
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 93  

5643          //----------------------------------------------------------------------------------------------------
5644          void GotoAdjustVolume(void)
5645          { 
5646   1          CInitOSDMainFrame();
5647   1      #if(_HARDWARE_LOAD_FONT == _ON)
              
                      CScalerLoadHardwareVLCFont(tFntIconSpker, 0x10);
              
              #else
5652   1      
5653   1          CScalerLoadFont(tFntIconSpker, 0x10, 6, _COMPRESS_FONT);
5654   1      
5655   1      #endif
5656   1      
5657   1           if (_GET_OSD_SIZE()) 
5658   1              OSDPosition(_OSD_DOUBLE_WIDTH(_VOLUME_WINDOW_WIDTH), _OSD_DOUBLE_HEIGHT(_VOLUME_WINDOW_HEIGHT), _V
             -OLUME_DOUBLE_H_OFFSET, _VOLUME_DOUBLE_V_OFFSET, 0x03);
5659   1            else
5660   1             OSDPosition(_VOLUME_WINDOW_WIDTH, _VOLUME_WINDOW_HEIGHT, _VOLUME_H_OFFSET, _VOLUME_V_OFFSET, 0x03);
5661   1      
5662   1          SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
5663   1      
5664   1          // Draw window
5665   1          COsdFxDrawWindow(XSTART(_VOLUME_WINDOW_H_POS), YSTART(_VOLUME_WINDOW_V_POS), XEND(_VOLUME_WINDOW_WIDTH
             -), YEND(_VOLUME_WINDOW_HEIGHT), tOSD_MINI_WINDOW_STYLE);
5666   1      
5667   1          if (STATE_MUTEON == GET_MUTE_STATE()) // Current mute on,so set mute off
5668   1          {
5669   2              SET_MUTE_STATE(STATE_MUTEOFF);
5670   2              CSetVolume();
5671   2          }
5672   1      
5673   1          DispIcon(1, 1, 0x10);
5674   1          OSDSlider(3, 1, 10, stOsdUserData.Volume, 100, 0x40, _SHOW_PERCENT);
5675   1          
5676   1          
5677   1          COsdFxEnableOsd();
5678   1          ucOsdState = MENU_VOLUME_SP;
5679   1      }
5680          
5681          #if(_KEY_TYPE_OSD007== _5KEY_SUPPORT)
              //----------------------------------------------------------------------------------------------------
              void GotoAdjustChanel(void)
              { 
                  CInitOSDMainFrame();
              
                  SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
              
                   if (_GET_OSD_SIZE()) 
                      OSDPosition(_OSD_DOUBLE_WIDTH(_VOLUME_WINDOW_WIDTH), _OSD_DOUBLE_HEIGHT(_VOLUME_WINDOW_HEIGHT), _V
             -OLUME_DOUBLE_H_OFFSET, _VOLUME_DOUBLE_V_OFFSET, 0x03);
                    else
                     OSDPosition(_VOLUME_WINDOW_WIDTH, _VOLUME_WINDOW_HEIGHT, _VOLUME_H_OFFSET, _VOLUME_V_OFFSET, 0x03);
              
              
                  // Draw window
                  COsdFxDrawWindow(XSTART(_VOLUME_WINDOW_H_POS), YSTART(_VOLUME_WINDOW_V_POS), XEND(_VOLUME_WINDOW_WIDTH
             -), YEND(_VOLUME_WINDOW_HEIGHT), tOSD_MINI_WINDOW_STYLE);
              #if(_NTSC_SEARCH_TABLE)
                   CLeftAlignTextout((BYTE *)sCATV_AIR[_GET_CATV_AIR()], 4, 2);
               #else
                 CLeftAlignTextout((BYTE *)sTV, 4, 2);    //060815
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 94  

              #endif
                 
                 OSDLine(2, 10, 14, 0x8c, BYTE_ATTRIB);
                 OSDClear(2, 1, 10, 14, 0x00, BYTE_DISPLAY);
                 CLR_KEYREPEATENABLE();
                 
                 Gotoxy(9, 2, BYTE_DISPLAY);
                if(stVDCColor.CurrentChannel<10)
                      {
                              OutputChar(0x00);           
                              OutputChar(0x00);           
                      }
                else if(stVDCColor.CurrentChannel<100)
                              OutputChar(0x00);            
                 CShowNumber(stVDCColor.CurrentChannel, 0);
               
                 ucTVType=CLoadChannelColorType(stVDCColor.CurrentChannel);
                      CLeftAlignTextout((BYTE  *)sTVType[ucTVType], 14, 2);
              
                 
                  COsdFxEnableOsd();
                  ucOsdState = MENU_CHANEL_SP;
              }
              #endif
5725          //----------------------------------------------------------------------------------------------------
5726          #if(_IR_ENABLE)        
5727          void SSetMuteState(void)
5728          {
5729   1          BYTE ucMuteCurrent = GET_MUTE_STATE();
5730   1          
5731   1          
5732   1          if (STATE_MUTEON == ucMuteCurrent) // Current mute on,so set mute off
5733   1          {
5734   2              SET_MUTE_STATE(STATE_MUTEOFF);
5735   2          }
5736   1          else
5737   1          {
5738   2              SET_MUTE_STATE(STATE_MUTEON);
5739   2          }
5740   1      
5741   1          DrawMuteState();
5742   1          
5743   1          CSetVolume();
5744   1      }
5745          #endif
5746          
5747          //----------------------------------------------------------------------------------------------------
5748          #if(_AUTO_POWER_DOWN)
5749          void CShowTimer(void)
5750          {
5751   1          BYTE ucCurrentMin = ucAutoPowerDownTime - 1;
5752   1          BYTE ucCurrentSec = 59 - (BYTE)(ucMinuteCount/1000);
5753   1          
5754   1          if (!bTimerOnScreen)
5755   1          {
5756   2              COsdFxDisableOsd();
5757   2              SetOSDRamAddress(ROW_COUNT,COL_WIDTH,FONT_BASE_ADDRESS);
5758   2              SetOSDDouble(OSD_DOUBLE_HEIGHT_ENABLE | OSD_DOUBLE_WIDTH_ENABLE);
5759   2              SetRowCmds(ROW_COUNT,COL_WIDTH);
5760   2              COsdFxCodeWrite(ucCloseAllWindow);
5761   2              CClearWindow(0x20);
5762   2      
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 95  

5763   2           //if (_GET_OSD_SIZE()) 
5764   2           //   OSDPosition(_OSD_DOUBLE_WIDTH(55), _OSD_DOUBLE_HEIGHT(30), _RIGHT_UP_OSD_H_OFFSET, 1, 0x03);
5765   2           // else
5766   2             OSDPosition(55, 30, _RIGHT_UP_OSD_H_OFFSET, 1, 0x03);
5767   2      
5768   2              COsdFxEnableOsd();
5769   2              bTimerOnScreen = 1;
5770   2          }
5771   1      
5772   1          COsdFxEnableOsd();
5773   1              
5774   1          Gotoxy(1,0,BYTE_DISPLAY);         
5775   1          CShowNumber(ucAutoPowerDownTime - 1, 2);
5776   1          OutputChar(0x3a);  // Show ":"
5777   1          CShowNumber(59 - (BYTE)(ucMinuteCount/1000), 2);
5778   1          
5779   1          
5780   1          CTimerReactiveTimerEvent(SEC(stOsdUserData.OsdTimeout),COsdDispOsdTimerEvent);
5781   1      }
5782          #endif
5783          
5784          
5785          #if(_VIDEO_CHIP == _VDC_TB1334)
5786          //----------------------------------------------------------------------------------------------------
5787          void CAudioCtrl(void)
5788          {
5789   1          if (_GET_INPUT_SOURCE() != _SOURCE_VIDEO_TV)
5790   1              return;
5791   1       /*
5792   1        #if(_VIDEO_TV_SUPPORT)
5793   1          if (bChangeChannel)
5794   1              return;
5795   1        #endif
5796   1      */
5797   1          if (ucAudioState != 0)
5798   1              ucAudioState++;
5799   1      
5800   1          if (ucAudioState < 5)
5801   1              return;
5802   1              
5803   1          if (!gmi_CModeLocked())  // TV no signal
5804   1              MUTE_ON();
5805   1          else
5806   1              CSetVolume();
5807   1      
5808   1          ucAudioState = 1;
5809   1      }
5810          #endif
5811          
5812          //----------------------------------------------------------------------------------------------------
5813          
5814          void HintDialog(void)
5815          {
5816   1          CInitOSDMainFrame();
5817   1              
5818   1      
5819   1           SetOSDDouble((_GET_OSD_SIZE() ? 0x03 : 0x00)  | OSD_WINDOWCHAR_BLENDING);   
5820   1           if (_GET_OSD_SIZE()) 
5821   1              OSDPosition(_OSD_DOUBLE_WIDTH(_HINT_WINDOW_H_END), _OSD_DOUBLE_HEIGHT(_HINT_WINDOW_V_END), _AUTO_H
             -_OFFSET, _AUTO_V_OFFSET, 0x03);
5822   1            else
5823   1             OSDPosition(_HINT_WINDOW_H_END, _HINT_WINDOW_V_END, _AUTO_DOUBLE_H_OFFSET, _AUTO_DOUBLE_V_OFFSET, 0
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 96  

             -x03);
5824   1      
5825   1          COsdFxDrawWindow(XSTART(_HINT_WINDOW_H_POS), YSTART(_HINT_WINDOW_V_POS), XEND(_HINT_WINDOW_H_END), YEN
             -D(_HINT_WINDOW_V_END), tOSD_MINI_WINDOW_STYLE);
5826   1      
5827   1          switch(ucOsdEventMsg)
5828   1          {
5829   2              case _SHOW_NOSIGNAL_MSG:
5830   2                  CenterTextout((BYTE *)sNoSignal[GET_LANGUAGE], 10, 2);
5831   2                  break;
5832   2      
5833   2              case _SHOW_NOSUPPORT_MSG:
5834   2                  CenterTextout((BYTE *)sNotSupport[GET_LANGUAGE], 10, 2);
5835   2                  break;
5836   2      
5837   2              case _SHOW_NOCABLE_MSG:
5838   2                  CenterTextout((BYTE *)sNoCable[GET_LANGUAGE], 10, 2);
5839   2                  CTimerCancelTimerEvent(COsdDispOsdTimerEvent);
5840   2                  break;
5841   2          }
5842   1         
5843   1          COsdFxEnableOsd();
5844   1          
5845   1          if(GET_PANELPOWERSTATUS() == _OFF)
5846   1              CPowerPanelOn();
5847   1          if (GET_LIGHTPOWERSTATUS() == _OFF)  
5848   1              CPowerLightPowerOn(); 
5849   1      }
5850          //----------------------------------------------------------------------------------------------------
5851          void CShowCurrentSourceTitle(BYTE ucHpos, BYTE ucVpos)
5852          {
5853   1          switch(_GET_INPUT_SOURCE())
5854   1          {
5855   2              case _SOURCE_VGA:             CLeftAlignTextout(sVGA, ucHpos, ucVpos);             break;
5856   2              case _SOURCE_DVI:             CLeftAlignTextout(sDVI, ucHpos, ucVpos);             break;
5857   2              case _SOURCE_HDMI:            CLeftAlignTextout(sHDMI, ucHpos, ucVpos);            break;
5858   2              case _SOURCE_VIDEO_AV:        CLeftAlignTextout(sVIDEO, ucHpos, ucVpos);           break;
5859   2              case _SOURCE_VIDEO_SV:        CLeftAlignTextout(sSVIDEO, ucHpos, ucVpos);          break;
5860   2              case _SOURCE_VIDEO_YUV:       CLeftAlignTextout(sYUV, ucHpos, ucVpos);             break;    
5861   2              case _SOURCE_VIDEO_TV:        CLeftAlignTextout(sTV, ucHpos, ucVpos);              break;
5862   2              case _SOURCE_YPBPR:           CLeftAlignTextout(sYPBPR, ucHpos, ucVpos);           break;
5863   2              case _SOURCE_VIDEO_SCART:     CLeftAlignTextout(sSCART, ucHpos, ucVpos);           break;
5864   2              case _SOURCE_VIDEO_DVD:      CLeftAlignTextout(sDVD, ucHpos, ucVpos);           break;
5865   2          }
5866   1      }
5867          
5868          #if(_IR_ENABLE)        
5869          //----------------------------------------------------------------------------------------------------
5870          void CDisplayCurrentSourceMessage(void)
5871          {
5872   1          CInitOSDMainFrame();
5873   1          SetOSDDouble( 0x03 );   
5874   1      
5875   1           if (_GET_OSD_SIZE()) 
5876   1              OSDPosition(_OSD_DOUBLE_WIDTH(220), _OSD_DOUBLE_HEIGHT(54), _LIFT_UP_H_OFFSET, 1, 0x03);
5877   1            else
5878   1             OSDPosition(220, 54, _LIFT_UP_H_OFFSET, 1, 0x03);
5879   1      
5880   1          OSDClear(0, 4, 0, 25, 0x20, BYTE_COLOR);  // Set message color to red
5881   1      
5882   1          CShowCurrentSourceTitle(1, 0);
5883   1          switch(_GET_INPUT_SOURCE())
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 97  

5884   1          {
5885   2          case _SOURCE_VGA:
5886   2          case _SOURCE_DVI:
5887   2          case _SOURCE_HDMI:
5888   2              //display display size
5889   2              Gotoxy(1, 2, 0x50);
5890   2              OutputDisplaySize();
5891   2              //display refresh
5892   2              Gotoxy(12, 2, 0x50);
5893   2              OutputChar('@');          
5894   2              OutputChar(0x00);            
5895   2              OutputRefrushRate();             
5896   2              break; 
5897   2      
5898   2      #if(_YPBPR_SUPPORT)
                  case _SOURCE_YPBPR:
                      if (stModeInfo.ModeCurr < _MAX_YPBPR_MODE)
                         CLeftAlignTextout((BYTE *)sYPbPrMode[stModeInfo.ModeCurr], 0, 2);
                      break;
              #endif
5904   2      
5905   2      #if(_VIDEO_SUPPORT)
5906   2          case _SOURCE_VIDEO_AV:
5907   2          case _SOURCE_VIDEO_SV:
5908   2          case _SOURCE_VIDEO_YUV:
5909   2          case _SOURCE_VIDEO_SCART:
5910   2              case _SOURCE_VIDEO_DVD:   
5911   2              if(CHECK60HZ())
5912   2                  CLeftAlignTextout(sNTSC, 1, 2);
5913   2              else
5914   2                  CLeftAlignTextout(sPAL, 1, 2);
5915   2              break;
5916   2      #endif
5917   2      
5918   2      #if(_VIDEO_TV_SUPPORT)
5919   2          case _SOURCE_VIDEO_TV:
5920   2              Gotoxy(1, 1, BYTE_DISPLAY);         
5921   2              CShowNumber(stVDCColor.CurrentChannel, 0);
5922   2      #if(_NTSC_SEARCH_TABLE)
                      CLeftAlignTextout((BYTE *)sCATV_AIR[_GET_CATV_AIR()],1,2);
                      CLeftAlignTextout((BYTE *)sTVType[ucTVType],1,3);
              #else           
5926   2              CLeftAlignTextout((BYTE *)sTVType[ucTVType],1,2);
5927   2      #endif
5928   2              break;
5929   2      #endif
5930   2          }
5931   1      
5932   1          CTimerReactiveTimerEvent(SEC(5),COsdDispOsdTimerEvent);
5933   1          COsdFxEnableOsd();         
5934   1      #if(_AUTO_POWER_DOWN)
5935   1          bTimerOnScreen = 0;
5936   1      #endif
5937   1      
5938   1          ucOsdState     = MENU_SHOW_MESSAGE_SATAE;
5939   1      }
5940          #endif
5941          
5942          //----------------------------------------------------------------------------------------------------
5943          void ShowNote(void)
5944          {
5945   1         if(GET_DO_SHOW_NOTE()==0)
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 98  

5946   1              {
5947   2          CInitOSDMainFrame();
5948   2          SetOSDDouble(OSD_DOUBLE_HEIGHT_ENABLE | OSD_DOUBLE_WIDTH_ENABLE);
5949   2      
5950   2      
5951   2           if (_GET_OSD_SIZE()) 
5952   2              OSDPosition(_OSD_DOUBLE_WIDTH(220), _OSD_DOUBLE_HEIGHT(54), _LIFT_UP_H_OFFSET, 1, 0x03);
5953   2            else
5954   2             OSDPosition(220, 54, _LIFT_UP_H_OFFSET, 1, 0x03);
5955   2      
5956   2          OSDLine(0, 0, 10, 0x20, BYTE_COLOR);
5957   2          CShowCurrentSourceTitle(0, 0);
5958   2          
5959   2          COsdFxEnableOsd();         
5960   2          CTimerReactiveTimerEvent(SEC(10),COsdDispOsdTimerEvent);
5961   2            
5962   2          if(GET_PANELPOWERSTATUS() == _OFF)
5963   2              CPowerPanelOn();
5964   2          if (GET_LIGHTPOWERSTATUS() == _OFF)  
5965   2              CPowerLightPowerOn(); 
5966   2              
5967   2              SET_DO_SHOW_NOTE(1);
5968   2              }
5969   1          ucOsdState = MENU_SHOW_MSG_STATE;
5970   1      }
5971          //--------------------------------------------------------------------------------------------------------
             --------------
5972          
5973          #if(IR_Test_EN== _ON)    
              void PrintfHex(BYTE Value)
              {
                   BYTE h,l,t;
              
                   t = (Value & 0x0f);
                   if (t < 10)    
                      l = t + '0';
                   else       
                      l = t -10 + 'A';
              
                   t = (Value >> 4) & 0x0f;
              
                   if (t < 10) 
                      h = t + '0';
                   else     
                      h = t - 10 + 'A';
              
                   CScalerSendAddr(_OSD_DATA_PORT_92, _WRITE, _NON_AUTOINC);
                   CScalerSendByte(h);
                   CScalerSendByte(l);
                   CScalerSendWriteStop();
              }
              
              void Display_IR(void)//LastLanguage()
              {
                      Gotoxy(2, 12, BYTE_DISPLAY);
                      PrintfHex(CUSTOM_CODE_STATE_H);PrintfHex(CUSTOM_CODE_STATE_L);
              
                      Gotoxy(2,13,BYTE_DISPLAY);
                      PrintfHex(CMD_DATA_INFO);
              
                   COsdFxEnableOsd();
              
C51 COMPILER V8.16   OSDPUB007                                                             04/05/2012 11:15:27 PAGE 99  

              }
              #endif
6009          
6010          //--------------------------------------------------------------------------------------------------------
             --------------
6011          #endif        //#if(OSD_TYPE == OSD03)


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8500    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      50
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
